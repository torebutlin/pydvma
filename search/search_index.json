{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pydvma","text":"<p>A Python package for dynamics and vibration measurements and analysis.</p>"},{"location":"#about-pydvma","title":"About pydvma","text":"<p>This is a modular library for data measurement and analysis in the context of dynamics and vibration, for use in student laboratory experiments as well as for research projects, developed at Cambridge University Engineering Department.</p> <p>A high-level interface allows straightforward application for common use-cases and a low-level interface provides more control when needed.</p> <p>The aim is for a library that is simple to use and simple to maintain. It is not a full-featured GUI, but when used in conjunction with Jupyter Notebooks it is intended to provide the best of both worlds: interactive tools for common tasks and a command line interface for customisation.</p>"},{"location":"#features","title":"Features","text":"<p>At present the library has basic functionality for:</p> <ul> <li>Logging data using soundcards or National Instrument DAQs</li> <li>Logging with pre-trigger for impulse response measurements</li> <li>Logging with PC generated output (soundcard and NIDAQ)</li> <li>Computing frequency domain data (FFT)</li> <li>Computing transfer function data</li> <li>Computing sonograms/spectrograms</li> <li>Basic modal analysis tools (mode-fitting, damping estimation)</li> <li>Saving and plotting data</li> <li>Export to Matlab and CSV</li> <li>Interactive tools for standard acquisition and analysis</li> <li>Oscilloscope view of input signals</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pydvma\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import pydvma as dvma\nimport matplotlib\n\n%matplotlib qt\nsettings = dvma.MySettings()\nlogger = dvma.Logger(settings)\n</code></pre> <p>For more detailed instructions, see the Getting Started guide.</p>"},{"location":"#documentation-overview","title":"Documentation Overview","text":"<ul> <li>Getting Started: Installation and setup instructions</li> <li>User Guide: Comprehensive guides for common tasks</li> <li>API Reference: Detailed API documentation</li> <li>Examples: Practical examples and tutorials</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions to this project are welcomed, keeping in mind the project aims above:</p> <ul> <li>If you find a bug, please report using GitHub's issue tracker</li> <li>For bug-fixes and refinements: please feel free to clone the repository, make edits and create a pull request with a clear description of changes made</li> <li>If you would like to make a more significant contribution or change, then please be in contact to outline your suggestion</li> </ul> <p>See the Contributing page for more details.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD 3-Clause License - see the License page for details.</p>"},{"location":"contributing-docstrings/","title":"Docstring Style Guide","text":"<p>This guide explains how to write docstrings for pydvma that will automatically appear in the documentation.</p>"},{"location":"contributing-docstrings/#overview","title":"Overview","text":"<p>pydvma uses mkdocstrings to automatically extract documentation from Python docstrings. When you update docstrings in the source code, the changes automatically appear in the online documentation.</p>"},{"location":"contributing-docstrings/#docstring-format","title":"Docstring Format","text":"<p>The codebase currently uses a simple format. You can use either:</p> <ol> <li>Simple Args format (current style in most of the codebase)</li> <li>Google style (recommended for new docstrings)</li> </ol> <p>Both will be parsed correctly by mkdocstrings.</p>"},{"location":"contributing-docstrings/#simple-args-format-current","title":"Simple Args Format (Current)","text":"<pre><code>def calculate_fft(time_data, time_range=None, window=None):\n    '''\n    Calculate FFT of time domain data.\n\n    Args:\n        time_data (&lt;TimeData&gt; object): time series data\n        time_range: 2x1 numpy array to specify data segment to use\n        window (str): window function name ('hann', 'blackman', etc.)\n\n    Returns:\n        &lt;FreqData&gt; object containing frequency domain data\n    '''\n    # Implementation...\n</code></pre>"},{"location":"contributing-docstrings/#google-style-format-recommended-for-new-code","title":"Google Style Format (Recommended for New Code)","text":"<pre><code>def calculate_fft(time_data, time_range=None, window=None):\n    \"\"\"Calculate FFT of time domain data.\n\n    Computes the Fast Fourier Transform of the input time series data,\n    with optional windowing and time range selection.\n\n    Args:\n        time_data (TimeData): Time series data to transform\n        time_range (array-like, optional): 2-element array [start, end]\n            specifying the time segment to use. If None, uses all data.\n        window (str, optional): Window function name. Options include\n            'hann', 'hamming', 'blackman', or None for rectangular window.\n            Defaults to None.\n\n    Returns:\n        FreqData: Frequency domain representation of the input data,\n            containing the complex spectrum and frequency axis.\n\n    Examples:\n        &gt;&gt;&gt; freq_data = calculate_fft(time_data, window='hann')\n        &gt;&gt;&gt; magnitude = np.abs(freq_data.freq_data)\n\n    Notes:\n        The frequency resolution is determined by the duration of the\n        selected time segment: \u0394f = 1/duration\n    \"\"\"\n    # Implementation...\n</code></pre>"},{"location":"contributing-docstrings/#class-docstrings","title":"Class Docstrings","text":"<pre><code>class TimeData:\n    \"\"\"Container for time-domain measurement data.\n\n    Stores time series data along with metadata, settings, and axis\n    information. Supports multi-channel data.\n\n    Attributes:\n        time_axis (ndarray): Time vector in seconds\n        time_data (ndarray): Signal data, shape (samples, channels)\n        settings: Acquisition settings object\n        test_name (str): Name identifier for this measurement\n        unique_id (str): Unique identifier for data traceability\n\n    Examples:\n        &gt;&gt;&gt; time_data = TimeData(t, y, settings, test_name='test_01')\n        &gt;&gt;&gt; channel_0 = time_data.time_data[:, 0]\n    \"\"\"\n\n    def __init__(self, time_axis, time_data, settings, test_name='', id_link=None):\n        \"\"\"Initialize TimeData object.\n\n        Args:\n            time_axis (ndarray): Time vector\n            time_data (ndarray): Signal data array\n            settings: Settings object\n            test_name (str, optional): Test identifier\n            id_link (str, optional): Link to parent data ID\n        \"\"\"\n        # Implementation...\n</code></pre>"},{"location":"contributing-docstrings/#type-hints","title":"Type Hints","text":"<p>Add type hints where possible:</p> <pre><code>from typing import Optional, Union, Tuple\nimport numpy as np\n\ndef calculate_tf(\n    time_data: 'TimeData',\n    ch_in: int = 0,\n    time_range: Optional[np.ndarray] = None,\n    window: Optional[str] = None,\n    N_frames: int = 1,\n    overlap: float = 0.5\n) -&gt; 'TfData':\n    \"\"\"Calculate transfer function from time domain data.\n\n    Args:\n        time_data: Input time series data\n        ch_in: Index of input channel\n        time_range: Time segment [start, end] or None for all data\n        window: Window function name or None\n        N_frames: Number of segments for averaging\n        overlap: Overlap fraction between segments (0 to 1)\n\n    Returns:\n        Transfer function data with coherence\n    \"\"\"\n    # Implementation...\n</code></pre>"},{"location":"contributing-docstrings/#sections-in-docstrings","title":"Sections in Docstrings","text":"<p>Common sections (all optional):</p> <ul> <li>Args: Function/method parameters</li> <li>Returns: Return value description</li> <li>Raises: Exceptions that may be raised</li> <li>Examples: Usage examples</li> <li>Notes: Additional information</li> <li>References: Citations or links</li> <li>See Also: Related functions</li> <li>Warnings: Important warnings for users</li> </ul>"},{"location":"contributing-docstrings/#examples-section","title":"Examples Section","text":"<p>Provide practical examples:</p> <pre><code>def calculate_damping_from_sono(time_data, n_chan=1, nperseg=None, start_time=None):\n    \"\"\"Calculate damping from sonogram analysis of free decay.\n\n    Analyzes the decay of spectral peaks in a sonogram to extract\n    modal parameters including natural frequencies and damping ratios.\n\n    Args:\n        time_data (TimeData): Time series containing free decay response\n        n_chan (int): Channel index to analyze. Defaults to 1.\n        nperseg (int, optional): FFT segment length for sonogram.\n            If None, automatically determined based on signal length.\n        start_time (float, optional): Time to start analysis in seconds.\n            If None, automatically detected from pretrigger settings.\n\n    Returns:\n        tuple: A tuple containing:\n            - fn (ndarray): Natural frequencies in Hz\n            - Qn (ndarray): Quality factors (Q = 1/(2\u03b6))\n            - fit_data (dict): Dictionary with fit visualization data:\n                - 't': time axis\n                - 'fits': list of fit dictionaries for each mode\n\n    Examples:\n        &gt;&gt;&gt; # Single impact test\n        &gt;&gt;&gt; fn, Qn, fit_data = calculate_damping_from_sono(time_data, n_chan=1)\n        &gt;&gt;&gt; zeta = 1 / (2 * Qn)  # Convert Q to damping ratio\n        &gt;&gt;&gt; print(f\"Mode 1: f={fn[0]:.1f} Hz, \u03b6={zeta[0]:.4f}\")\n\n        &gt;&gt;&gt; # Specify custom parameters\n        &gt;&gt;&gt; fn, Qn, fit_data = calculate_damping_from_sono(\n        ...     time_data,\n        ...     n_chan=0,\n        ...     nperseg=1024,\n        ...     start_time=0.05\n        ... )\n\n    Notes:\n        The method identifies frequency peaks in the initial spectrum and\n        tracks their exponential decay over time. Better results are obtained\n        with:\n        - Good signal-to-noise ratio\n        - Sufficient decay duration (several oscillation periods)\n        - Appropriate nperseg choice based on frequency spacing\n\n    See Also:\n        calculate_sonogram: Compute the underlying sonogram\n        calculate_tf: Alternative method for modal identification\n    \"\"\"\n    # Implementation...\n</code></pre>"},{"location":"contributing-docstrings/#what-gets-documented","title":"What Gets Documented","text":"<p>mkdocstrings automatically extracts:</p> <ul> <li>\u2705 Function and method signatures</li> <li>\u2705 Parameter descriptions from docstrings</li> <li>\u2705 Return value descriptions</li> <li>\u2705 Class attributes</li> <li>\u2705 Examples</li> <li>\u2705 Type hints (if provided)</li> </ul>"},{"location":"contributing-docstrings/#testing-your-docstrings","title":"Testing Your Docstrings","text":""},{"location":"contributing-docstrings/#local-preview","title":"Local Preview","text":"<pre><code># Install dependencies\npip install -r requirements-docs.txt\n\n# Serve documentation locally\nmkdocs serve\n</code></pre> <p>Navigate to the API reference page for your module to see how it looks.</p>"},{"location":"contributing-docstrings/#docstring-linting","title":"Docstring Linting","text":"<p>Use <code>pydocstyle</code> to check docstring quality:</p> <pre><code>pip install pydocstyle\npydocstyle pydvma/analysis.py\n</code></pre>"},{"location":"contributing-docstrings/#migration-strategy","title":"Migration Strategy","text":"<p>To gradually improve documentation:</p> <ol> <li>New code: Use Google-style docstrings with type hints</li> <li>Existing code: Update docstrings as you modify functions</li> <li>Priority: Focus on user-facing functions first</li> <li>No rush: The current simple format works; improve over time</li> </ol>"},{"location":"contributing-docstrings/#best-practices","title":"Best Practices","text":""},{"location":"contributing-docstrings/#do","title":"Do \u2705","text":"<ul> <li>Describe what the function does in one clear sentence</li> <li>Document all parameters and return values</li> <li>Provide at least one usage example</li> <li>Explain units (Hz, seconds, etc.)</li> <li>Note important limitations or assumptions</li> </ul>"},{"location":"contributing-docstrings/#dont","title":"Don't \u274c","text":"<ul> <li>Don't duplicate information already in type hints</li> <li>Don't describe implementation details (use code comments instead)</li> <li>Don't write overly long docstrings (link to user guide for details)</li> <li>Don't forget to update docstrings when changing function behavior</li> </ul>"},{"location":"contributing-docstrings/#live-documentation-updates","title":"Live Documentation Updates","text":"<p>When you push changes to GitHub:</p> <ol> <li>Commit updated source files with new docstrings</li> <li>Push to master/main branch</li> <li>GitHub Actions automatically rebuilds documentation</li> <li>Changes appear online within minutes</li> </ol> <p>No need to manually update API reference pages - mkdocstrings handles it automatically!</p>"},{"location":"contributing-docstrings/#further-reading","title":"Further Reading","text":"<ul> <li>Google Style Guide</li> <li>PEP 257 - Docstring Conventions</li> <li>mkdocstrings Documentation</li> </ul>"},{"location":"contributing/","title":"Contributing to pydvma","text":"<p>Contributions to this project are welcomed! This page provides guidelines for contributing.</p>"},{"location":"contributing/#project-goals","title":"Project Goals","text":"<p>Keep in mind the project aims:</p> <ul> <li>Simple to use</li> <li>Simple to maintain</li> <li>Modular architecture</li> <li>Work well with Jupyter notebooks</li> <li>Suitable for teaching and research</li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a bug:</p> <ol> <li>Check if it's already reported in GitHub Issues</li> <li>If not, create a new issue with:</li> <li>Clear description of the problem</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Your environment (OS, Python version, pydvma version)</li> </ol>"},{"location":"contributing/#contributing-code","title":"Contributing Code","text":""},{"location":"contributing/#bug-fixes-and-refinements","title":"Bug Fixes and Refinements","text":"<p>For bug fixes and small improvements:</p> <ol> <li>Fork the repository</li> <li>Create a branch for your changes</li> <li>Make your changes with clear commit messages</li> <li>Test your changes</li> <li>Create a pull request with a clear description</li> </ol>"},{"location":"contributing/#significant-contributions","title":"Significant Contributions","text":"<p>For larger changes or new features:</p> <ol> <li>Open an issue to discuss your proposal first</li> <li>Wait for feedback before starting work</li> <li>Follow the same process as above once approved</li> </ol>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone repository\ngit clone https://github.com/torebutlin/pydvma.git\ncd pydvma\n\n# Install in development mode\npip install -e .\n\n# Install development dependencies\npip install pytest sphinx mkdocs mkdocs-material mkdocstrings[python]\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 guidelines</li> <li>Use meaningful variable names</li> <li>Add docstrings for new functions</li> <li>Comment complex logic</li> <li>Keep functions focused and modular</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Test your changes:</p> <pre><code># Test basic functionality\nimport pydvma as dvma\n\nsettings = dvma.MySettings()\n# ... test your changes\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Update documentation when adding features:</p> <ul> <li>Add docstrings to new functions</li> <li>Update relevant user guide pages</li> <li>Add examples if appropriate</li> </ul>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>A good pull request:</p> <ul> <li>Has a clear title and description</li> <li>Explains what changed and why</li> <li>References related issues</li> <li>Includes tests if applicable</li> <li>Updates documentation if needed</li> <li>Keeps changes focused on one topic</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have questions about contributing, open an issue or contact the maintainers.</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the BSD 3-Clause License.</p>"},{"location":"license/","title":"License","text":"<p>pydvma is licensed under the BSD 3-Clause License.</p> <pre><code>BSD 3-Clause License\n\nCopyright (c) 2018-present, Tore Butlin\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"api/acquisition/","title":"Acquisition Module","text":"<p>Data acquisition functions for logging data from soundcards and National Instruments DAQ devices.</p>"},{"location":"api/acquisition/#main-acquisition-function","title":"Main Acquisition Function","text":""},{"location":"api/acquisition/#pydvma.acquisition.log_data","title":"log_data","text":"<pre><code>log_data(settings, test_name=None, rec=None, output=None)\n</code></pre> <p>Logs data according to settings and returns DataSet class</p>"},{"location":"api/acquisition/#signal-generation","title":"Signal Generation","text":""},{"location":"api/acquisition/#pydvma.acquisition.output_signal","title":"output_signal","text":"<pre><code>output_signal(settings, output)\n</code></pre>"},{"location":"api/acquisition/#pydvma.acquisition.signal_generator","title":"signal_generator","text":"<pre><code>signal_generator(settings, sig='gaussian', T=1, amplitude=0.1, f=None, selected_channels='all')\n</code></pre> <p>Creates a signal ready for output to a chosen device</p>"},{"location":"api/acquisition/#stream-monitoring","title":"Stream Monitoring","text":""},{"location":"api/acquisition/#pydvma.acquisition.stream_snapshot","title":"stream_snapshot","text":"<pre><code>stream_snapshot(rec)\n</code></pre>"},{"location":"api/analysis/","title":"Analysis Module","text":"<p>Analysis functions for frequency domain analysis, transfer functions, and modal analysis.</p>"},{"location":"api/analysis/#fft-analysis","title":"FFT Analysis","text":""},{"location":"api/analysis/#pydvma.analysis.calculate_fft","title":"calculate_fft","text":"<pre><code>calculate_fft(time_data, time_range=None, window=None)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>time_data</code>               (<code>&lt;TimeData&gt; object</code>)           \u2013            <p>time series data</p> </li> <li> <code>time_range</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>2x1 numpy array to specify data segment to use</p> </li> <li> <code>window</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>window function name (e.g., 'hann', 'hamming', 'blackman'), or None for rectangular (boxcar) window</p> </li> </ul>"},{"location":"api/analysis/#transfer-functions","title":"Transfer Functions","text":""},{"location":"api/analysis/#pydvma.analysis.calculate_tf","title":"calculate_tf","text":"<pre><code>calculate_tf(time_data, ch_in=0, time_range=None, window=None, N_frames=1, overlap=0.5)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>time_data</code>               (<code>&lt;TimeData&gt; object</code>)           \u2013            <p>time series data</p> </li> <li> <code>ch_in</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>index of input channel</p> </li> <li> <code>time_range</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>2x1 numpy array to specify data segment to use</p> </li> <li> <code>window</code>               (<code>None or str</code>, default:                   <code>None</code> )           \u2013            <p>apply filter to data before fft or not</p> </li> <li> <code>N_frames</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>number of frames to average over</p> </li> <li> <code>overlap</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>frame overlap fraction between 0 and 1</p> </li> </ul>"},{"location":"api/analysis/#pydvma.analysis.calculate_tf_averaged","title":"calculate_tf_averaged","text":"<pre><code>calculate_tf_averaged(time_data_list, ch_in=0, time_range=None, window=None)\n</code></pre> <p>Calculates transfer function averaged across ensemble of timedata. Note that this expects a Python list of timedata objects.</p> <p>Takes each time series as an independent measurement.</p> <p>Intended for averaged transfer functions from separate measurements, e.g. impulse hammer tests.</p> <p>Does not average data across sub-frames.</p> <p>Parameters:</p> <ul> <li> <code>time_data_list</code>               (<code>&lt;TimeDataList&gt; object</code>)           \u2013            <p>a list of time series data</p> </li> <li> <code>ch_in</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>index of input channel</p> </li> <li> <code>time_range</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>2x1 numpy array to specify data segment to use</p> </li> <li> <code>window</code>               (<code>None or str</code>, default:                   <code>None</code> )           \u2013            <p>type of window to use, default is None.</p> </li> </ul>"},{"location":"api/analysis/#cross-spectrum-analysis","title":"Cross-Spectrum Analysis","text":""},{"location":"api/analysis/#pydvma.analysis.calculate_cross_spectrum_matrix","title":"calculate_cross_spectrum_matrix","text":"<pre><code>calculate_cross_spectrum_matrix(time_data, time_range=None, window=None, N_frames=1, overlap=0.5)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>time_data</code>               (<code>&lt;TimeData&gt; object</code>)           \u2013            <p>time series data</p> </li> <li> <code>time_range</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>2x1 numpy array to specify data segment to use</p> </li> <li> <code>window</code>               (<code>None or str</code>, default:                   <code>None</code> )           \u2013            <p>apply filter to data before fft or not</p> </li> <li> <code>N_frames</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>number of frames to average over</p> </li> <li> <code>overlap</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>frame overlap fraction between 0 and 1</p> </li> </ul>"},{"location":"api/analysis/#pydvma.analysis.calculate_cross_spectra_averaged","title":"calculate_cross_spectra_averaged","text":"<pre><code>calculate_cross_spectra_averaged(time_data_list, time_range=None, window=None)\n</code></pre> <p>Calculates cross spectra averaged across ensemble of time_data_list. Note that this expects a  of  objects. <p>Takes each time series as an independent measurement.</p> <p>Intended for averaged transfer functions from separate measurements, e.g. impulse hammer tests.</p> <p>Does not average data across sub-frames.</p> <p>Parameters:</p> <ul> <li> <code>time_data_list</code>               (<code>&lt;TimeDataList&gt; object</code>)           \u2013            <p>a list of time series data</p> </li> <li> <code>time_range</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>2x1 numpy array to specify data segment to use</p> </li> <li> <code>window</code>               (<code>None or str</code>, default:                   <code>None</code> )           \u2013            <p>type of window to use, default is None.</p> </li> </ul>"},{"location":"api/analysis/#time-frequency-analysis","title":"Time-Frequency Analysis","text":""},{"location":"api/analysis/#pydvma.analysis.calculate_sonogram","title":"calculate_sonogram","text":"<pre><code>calculate_sonogram(time_data, nperseg=None, noverlap=None)\n</code></pre>"},{"location":"api/analysis/#modal-analysis","title":"Modal Analysis","text":""},{"location":"api/analysis/#pydvma.analysis.calculate_damping_from_sono","title":"calculate_damping_from_sono","text":"<pre><code>calculate_damping_from_sono(time_data, n_chan=1, nperseg=None, start_time=None)\n</code></pre> <p>Calculate damping from sonogram data.</p> <p>Parameters:</p> <ul> <li> <code>time_data</code>               (<code>&lt;TimeData&gt; object</code>)           \u2013            <p>time series data</p> </li> <li> <code>n_chan</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>channel index to analyze, default is 1</p> </li> <li> <code>nperseg</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>number of samples per segment for spectrogram</p> </li> <li> <code>start_time</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>start time for analysis</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>fn</code> (              <code>ndarray</code> )          \u2013            <p>array of natural frequencies (Hz)</p> </li> <li> <code>Qn</code> (              <code>ndarray</code> )          \u2013            <p>array of Q factors (1/(2*zeta))</p> </li> <li> <code>fit_data</code> (              <code>dict</code> )          \u2013            <p>dict containing data needed for plotting the fits: - 't': time axis - 'fits': list of dicts, each with keys:     - 't_fit': time values for the fit region     - 'real_fit': fitted real part values     - 'real_data': actual real part data values     - 'f_peak': peak frequency (Hz)     - 'Qn': Q factor for this mode</p> </li> </ul>"},{"location":"api/analysis/#signal-processing","title":"Signal Processing","text":""},{"location":"api/analysis/#pydvma.analysis.multiply_by_power_of_iw","title":"multiply_by_power_of_iw","text":"<pre><code>multiply_by_power_of_iw(data, power, channel_list)\n</code></pre>"},{"location":"api/analysis/#pydvma.analysis.clean_impulse","title":"clean_impulse","text":"<pre><code>clean_impulse(time_data, ch_impulse=0)\n</code></pre> <p>Sets all data outside of impulse to zero.</p> <p>Pulse width is estimated by assuming half cosine impulse, using width of half peak amplitude.</p> <p>Data before peak is unchanged. Data after estimated end of impulse is ramped to zero using half cosine pulse of width 10x estimated pulse width.</p>"},{"location":"api/analysis/#pydvma.analysis.best_match","title":"best_match","text":"<pre><code>best_match(tf_data_list, freq_range=None, set_ref=0, ch_ref=0)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>tf_data_list</code>               (<code>&lt;TfDataList&gt; object</code>)           \u2013            <p>transfer function data</p> </li> <li> <code>freq_range</code>               (<code>list or ndarray</code>, default:                   <code>None</code> )           \u2013            <p>2x1 numpy array to specify data segment to use</p> </li> <li> <code>set_ref</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>reference set index, default is 0</p> </li> <li> <code>ch_ref</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>reference channel index, default is 0</p> </li> </ul>"},{"location":"api/analysis/#helper-functions","title":"Helper Functions","text":""},{"location":"api/analysis/#pydvma.analysis.func_real","title":"func_real","text":"<pre><code>func_real(t, A, B, N)\n</code></pre>"},{"location":"api/analysis/#pydvma.analysis.func_imag","title":"func_imag","text":"<pre><code>func_imag(t, W, C)\n</code></pre>"},{"location":"api/datastructure/","title":"Data Structure Module","text":"<p>Core data structures for storing and managing measurement data.</p>"},{"location":"api/datastructure/#main-container","title":"Main Container","text":""},{"location":"api/datastructure/#pydvma.datastructure.DataSet","title":"DataSet","text":""},{"location":"api/datastructure/#pydvma.datastructure.DataSet-attributes","title":"Attributes","text":""},{"location":"api/datastructure/#pydvma.datastructure.DataSet.time_data_list","title":"time_data_list  <code>instance-attribute</code>","text":"<pre><code>time_data_list = TimeDataList()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.freq_data_list","title":"freq_data_list  <code>instance-attribute</code>","text":"<pre><code>freq_data_list = FreqDataList()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.cross_spec_data_list","title":"cross_spec_data_list  <code>instance-attribute</code>","text":"<pre><code>cross_spec_data_list = CrossSpecDataList()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.tf_data_list","title":"tf_data_list  <code>instance-attribute</code>","text":"<pre><code>tf_data_list = TfDataList()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.modal_data_list","title":"modal_data_list  <code>instance-attribute</code>","text":"<pre><code>modal_data_list = ModalDataList()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.sono_data_list","title":"sono_data_list  <code>instance-attribute</code>","text":"<pre><code>sono_data_list = SonoDataList()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.meta_data_list","title":"meta_data_list  <code>instance-attribute</code>","text":"<pre><code>meta_data_list = MetaDataList()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.pydvma_version","title":"pydvma_version  <code>instance-attribute</code>","text":"<pre><code>pydvma_version = VERSION\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.DataSet.__init__","title":"__init__","text":"<pre><code>__init__(data=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.add_to_dataset","title":"add_to_dataset","text":"<pre><code>add_to_dataset(data)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.replace_data_item","title":"replace_data_item","text":"<pre><code>replace_data_item(data, n_set)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.remove_last_data_item","title":"remove_last_data_item","text":"<pre><code>remove_last_data_item(data_class)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.remove_data_item_by_index","title":"remove_data_item_by_index","text":"<pre><code>remove_data_item_by_index(data_class, list_index)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.calculate_fft_set","title":"calculate_fft_set","text":"<pre><code>calculate_fft_set(time_range=None, window=None)\n</code></pre> <p>Calls analysis.calculate_fft on each TimeData item in the TimeDataList and adds FreqDataList object to dataset</p>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.calculate_tf_set","title":"calculate_tf_set","text":"<pre><code>calculate_tf_set(ch_in=0, time_range=None, window=None, N_frames=1, overlap=0.5)\n</code></pre> <p>Calls analysis.calculate_fft on each TimeData item in the TimeDataList and adds FreqDataList object to dataset</p>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.calculate_cross_spectrum_matrix_set","title":"calculate_cross_spectrum_matrix_set","text":"<pre><code>calculate_cross_spectrum_matrix_set(ch_in=0, time_range=None, window='hann', N_frames=1, overlap=0.5)\n</code></pre> <p>Calls analysis.calculate_fft on each TimeData item in the TimeDataList and adds FreqDataList object to dataset</p>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.calculate_tf_averaged","title":"calculate_tf_averaged","text":"<pre><code>calculate_tf_averaged(ch_in=0, time_range=None, window='hann')\n</code></pre> <p>Calls analysis.calculate_fft on each TimeData item in the TimeDataList and adds FreqDataList object to dataset</p>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.calculate_cross_spectra_averaged","title":"calculate_cross_spectra_averaged","text":"<pre><code>calculate_cross_spectra_averaged(time_range=None, window=None)\n</code></pre> <p>Calls analysis.calculate_fft on each TimeData item in the TimeDataList and adds FreqDataList object to dataset</p>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.calculate_sono_set","title":"calculate_sono_set","text":"<pre><code>calculate_sono_set(nperseg=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.clean_impulse","title":"clean_impulse","text":"<pre><code>clean_impulse(ch_impulse=0)\n</code></pre> <p>Calls analysis.clean_impulse on each TimeData item in the TimeDataList and returns a copy of the new dataset.</p> <p>Note that calling this function does not change the data, and just returns a copy.</p>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.save_data","title":"save_data","text":"<pre><code>save_data(filename=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.export_to_matlab","title":"export_to_matlab","text":"<pre><code>export_to_matlab(filename=None, overwrite_without_prompt=False)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.export_to_matlab_jwlogger","title":"export_to_matlab_jwlogger","text":"<pre><code>export_to_matlab_jwlogger(filename=None, overwrite_without_prompt=False)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.plot_time_data","title":"plot_time_data","text":"<pre><code>plot_time_data(sets='all', channels='all')\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.plot_freq_data","title":"plot_freq_data","text":"<pre><code>plot_freq_data(sets='all', channels='all')\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.plot_tf_data","title":"plot_tf_data","text":"<pre><code>plot_tf_data(sets='all', channels='all')\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.plot_sono_data","title":"plot_sono_data","text":"<pre><code>plot_sono_data(n_set=0, n_chan=0, db_range=60)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.DataSet.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre>"},{"location":"api/datastructure/#time-domain-data","title":"Time Domain Data","text":""},{"location":"api/datastructure/#pydvma.datastructure.TimeData","title":"TimeData","text":""},{"location":"api/datastructure/#pydvma.datastructure.TimeData-attributes","title":"Attributes","text":""},{"location":"api/datastructure/#pydvma.datastructure.TimeData.time_axis","title":"time_axis  <code>instance-attribute</code>","text":"<pre><code>time_axis = time_axis\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.time_data","title":"time_data  <code>instance-attribute</code>","text":"<pre><code>time_data = time_data\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = settings\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp = timestamp\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.timestring","title":"timestring  <code>instance-attribute</code>","text":"<pre><code>timestring = timestring\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.channel_cal_factors","title":"channel_cal_factors  <code>instance-attribute</code>","text":"<pre><code>channel_cal_factors = channel_cal_factors\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.id_link","title":"id_link  <code>instance-attribute</code>","text":"<pre><code>id_link = id_link\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.test_name","title":"test_name  <code>instance-attribute</code>","text":"<pre><code>test_name = test_name\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.unique_id","title":"unique_id  <code>instance-attribute</code>","text":"<pre><code>unique_id = uuid4()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.TimeData.__init__","title":"__init__","text":"<pre><code>__init__(time_axis, time_data, settings, timestamp=None, timestring=None, units=None, channel_cal_factors=None, id_link=None, test_name=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeData.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList","title":"TimeDataList","text":"<p>               Bases: <code>list</code></p>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.calculate_fft_set","title":"calculate_fft_set","text":"<pre><code>calculate_fft_set(time_range=None, window=None)\n</code></pre> <p>Calls analysis.calculate_fft on each item in the list and returns FreqDataList object</p>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.calculate_tf_set","title":"calculate_tf_set","text":"<pre><code>calculate_tf_set(ch_in=0, time_range=None, window=None, N_frames=1, overlap=0.5)\n</code></pre> <p>Calls analysis.calculate_tf on each item in the list and returns TfDataList object</p>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.calculate_cross_spectrum_matrix_set","title":"calculate_cross_spectrum_matrix_set","text":"<pre><code>calculate_cross_spectrum_matrix_set(ch_in=0, time_range=None, window=None, N_frames=1, overlap=0.5)\n</code></pre> <p>Calls analysis.calculate_tf on each item in the list and returns TfDataList object</p>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.calculate_tf_averaged","title":"calculate_tf_averaged","text":"<pre><code>calculate_tf_averaged(ch_in=0, time_range=None, window='hann')\n</code></pre> <p>Calls analysis.calculate_tf_averaged on whole list and returns TfData object</p>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.calculate_cross_spectra_averaged","title":"calculate_cross_spectra_averaged","text":"<pre><code>calculate_cross_spectra_averaged(time_range=None, window=None)\n</code></pre> <p>Calls analysis.calculate_tf_averaged on whole list and returns TfData object</p>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.calculate_sono_set","title":"calculate_sono_set","text":"<pre><code>calculate_sono_set(nperseg=None)\n</code></pre> <p>Calls analysis.calculate_sonogram on each item in the list and returns SonoDataList object</p>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.get_calibration_factors","title":"get_calibration_factors","text":"<pre><code>get_calibration_factors()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.set_calibration_factors_all","title":"set_calibration_factors_all","text":"<pre><code>set_calibration_factors_all(factors)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.set_calibration_factor","title":"set_calibration_factor","text":"<pre><code>set_calibration_factor(factor, n_set=0, n_chan=0)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TimeDataList.export_to_csv","title":"export_to_csv","text":"<pre><code>export_to_csv(filename=None, overwrite_without_prompt=False)\n</code></pre>"},{"location":"api/datastructure/#frequency-domain-data","title":"Frequency Domain Data","text":""},{"location":"api/datastructure/#pydvma.datastructure.FreqData","title":"FreqData","text":""},{"location":"api/datastructure/#pydvma.datastructure.FreqData-attributes","title":"Attributes","text":""},{"location":"api/datastructure/#pydvma.datastructure.FreqData.freq_axis","title":"freq_axis  <code>instance-attribute</code>","text":"<pre><code>freq_axis = freq_axis\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.freq_data","title":"freq_data  <code>instance-attribute</code>","text":"<pre><code>freq_data = freq_data\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = settings\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.test_name","title":"test_name  <code>instance-attribute</code>","text":"<pre><code>test_name = test_name\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.channel_cal_factors","title":"channel_cal_factors  <code>instance-attribute</code>","text":"<pre><code>channel_cal_factors = channel_cal_factors\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.id_link","title":"id_link  <code>instance-attribute</code>","text":"<pre><code>id_link = id_link\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp = t\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.timestring","title":"timestring  <code>instance-attribute</code>","text":"<pre><code>timestring = '_' + str(year) + '_' + str(month) + '_' + str(day) + '_at_' + str(hour) + '_' + str(minute) + '_' + str(second)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.FreqData.__init__","title":"__init__","text":"<pre><code>__init__(freq_axis, freq_data, settings, units=None, channel_cal_factors=None, id_link=None, test_name=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqData.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqDataList","title":"FreqDataList","text":"<p>               Bases: <code>list</code></p>"},{"location":"api/datastructure/#pydvma.datastructure.FreqDataList-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.FreqDataList.get_calibration_factors","title":"get_calibration_factors","text":"<pre><code>get_calibration_factors()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqDataList.set_calibration_factors_all","title":"set_calibration_factors_all","text":"<pre><code>set_calibration_factors_all(factors)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqDataList.set_calibration_factor","title":"set_calibration_factor","text":"<pre><code>set_calibration_factor(factor, n_set=0, n_chan=0)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.FreqDataList.export_to_csv","title":"export_to_csv","text":"<pre><code>export_to_csv(filename=None, overwrite_without_prompt=False)\n</code></pre>"},{"location":"api/datastructure/#transfer-function-data","title":"Transfer Function Data","text":""},{"location":"api/datastructure/#pydvma.datastructure.TfData","title":"TfData","text":""},{"location":"api/datastructure/#pydvma.datastructure.TfData-attributes","title":"Attributes","text":""},{"location":"api/datastructure/#pydvma.datastructure.TfData.freq_axis","title":"freq_axis  <code>instance-attribute</code>","text":"<pre><code>freq_axis = freq_axis\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.tf_data","title":"tf_data  <code>instance-attribute</code>","text":"<pre><code>tf_data = tf_data\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.tf_coherence","title":"tf_coherence  <code>instance-attribute</code>","text":"<pre><code>tf_coherence = tf_coherence\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = settings\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.test_name","title":"test_name  <code>instance-attribute</code>","text":"<pre><code>test_name = test_name\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.channel_cal_factors","title":"channel_cal_factors  <code>instance-attribute</code>","text":"<pre><code>channel_cal_factors = channel_cal_factors\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.id_link","title":"id_link  <code>instance-attribute</code>","text":"<pre><code>id_link = id_link\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp = t\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.timestring","title":"timestring  <code>instance-attribute</code>","text":"<pre><code>timestring = '_' + str(year) + '_' + str(month) + '_' + str(day) + '_at_' + str(hour) + '_' + str(minute) + '_' + str(second)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.flag_modal_TF","title":"flag_modal_TF  <code>instance-attribute</code>","text":"<pre><code>flag_modal_TF = False\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.TfData.__init__","title":"__init__","text":"<pre><code>__init__(freq_axis, tf_data, tf_coherence, settings, units=None, channel_cal_factors=None, id_link=None, test_name=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfData.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfDataList","title":"TfDataList","text":"<p>               Bases: <code>list</code></p>"},{"location":"api/datastructure/#pydvma.datastructure.TfDataList-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.TfDataList.get_calibration_factors","title":"get_calibration_factors","text":"<pre><code>get_calibration_factors()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfDataList.set_calibration_factors_all","title":"set_calibration_factors_all","text":"<pre><code>set_calibration_factors_all(factors)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfDataList.set_calibration_factor","title":"set_calibration_factor","text":"<pre><code>set_calibration_factor(factor, n_set=0, n_chan=0)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfDataList.add_modal_reconstruction","title":"add_modal_reconstruction","text":"<pre><code>add_modal_reconstruction(tf_data, mode='replace')\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.TfDataList.export_to_csv","title":"export_to_csv","text":"<pre><code>export_to_csv(filename=None, overwrite_without_prompt=False)\n</code></pre>"},{"location":"api/datastructure/#sonogram-data","title":"Sonogram Data","text":""},{"location":"api/datastructure/#pydvma.datastructure.SonoData","title":"SonoData","text":""},{"location":"api/datastructure/#pydvma.datastructure.SonoData-attributes","title":"Attributes","text":""},{"location":"api/datastructure/#pydvma.datastructure.SonoData.time_axis","title":"time_axis  <code>instance-attribute</code>","text":"<pre><code>time_axis = time_axis\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.freq_axis","title":"freq_axis  <code>instance-attribute</code>","text":"<pre><code>freq_axis = freq_axis\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.sono_data","title":"sono_data  <code>instance-attribute</code>","text":"<pre><code>sono_data = sono_data\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = settings\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.test_name","title":"test_name  <code>instance-attribute</code>","text":"<pre><code>test_name = test_name\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.channel_cal_factors","title":"channel_cal_factors  <code>instance-attribute</code>","text":"<pre><code>channel_cal_factors = channel_cal_factors\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.id_link","title":"id_link  <code>instance-attribute</code>","text":"<pre><code>id_link = id_link\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp = t\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.timestring","title":"timestring  <code>instance-attribute</code>","text":"<pre><code>timestring = '_' + str(year) + '_' + str(month) + '_' + str(day) + '_at_' + str(hour) + '_' + str(minute) + '_' + str(second)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.SonoData.__init__","title":"__init__","text":"<pre><code>__init__(time_axis, freq_axis, sono_data, settings, units=None, channel_cal_factors=None, id_link=None, test_name=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoData.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.SonoDataList","title":"SonoDataList","text":"<p>               Bases: <code>list</code></p>"},{"location":"api/datastructure/#cross-spectrum-data","title":"Cross-Spectrum Data","text":""},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData","title":"CrossSpecData","text":""},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData-attributes","title":"Attributes","text":""},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.freq_axis","title":"freq_axis  <code>instance-attribute</code>","text":"<pre><code>freq_axis = freq_axis\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.Pxy","title":"Pxy  <code>instance-attribute</code>","text":"<pre><code>Pxy = Pxy\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.Cxy","title":"Cxy  <code>instance-attribute</code>","text":"<pre><code>Cxy = Cxy\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = settings\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.test_name","title":"test_name  <code>instance-attribute</code>","text":"<pre><code>test_name = test_name\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.channel_cal_factors","title":"channel_cal_factors  <code>instance-attribute</code>","text":"<pre><code>channel_cal_factors = channel_cal_factors\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.id_link","title":"id_link  <code>instance-attribute</code>","text":"<pre><code>id_link = id_link\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp = t\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.timestring","title":"timestring  <code>instance-attribute</code>","text":"<pre><code>timestring = '_' + str(year) + '_' + str(month) + '_' + str(day) + '_at_' + str(hour) + '_' + str(minute) + '_' + str(second)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.__init__","title":"__init__","text":"<pre><code>__init__(freq_axis, Pxy, Cxy, settings, units=None, channel_cal_factors=None, id_link=None, test_name=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecData.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.CrossSpecDataList","title":"CrossSpecDataList","text":"<p>               Bases: <code>list</code></p>"},{"location":"api/datastructure/#modal-data","title":"Modal Data","text":""},{"location":"api/datastructure/#pydvma.datastructure.ModalData","title":"ModalData","text":""},{"location":"api/datastructure/#pydvma.datastructure.ModalData-attributes","title":"Attributes","text":""},{"location":"api/datastructure/#pydvma.datastructure.ModalData.M","title":"M  <code>instance-attribute</code>","text":"<pre><code>M = []\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.test_name","title":"test_name  <code>instance-attribute</code>","text":"<pre><code>test_name = test_name\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = settings\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.channels","title":"channels  <code>instance-attribute</code>","text":"<pre><code>channels = 0\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.id_link","title":"id_link  <code>instance-attribute</code>","text":"<pre><code>id_link = id_link\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp = t\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.timestring","title":"timestring  <code>instance-attribute</code>","text":"<pre><code>timestring = '_' + str(year) + '_' + str(month) + '_' + str(day) + '_at_' + str(hour) + '_' + str(minute) + '_' + str(second)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.ModalData.__init__","title":"__init__","text":"<pre><code>__init__(xn=None, settings=None, units=None, id_link=None, test_name=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.add_mode","title":"add_mode","text":"<pre><code>add_mode(xn)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.delete_mode","title":"delete_mode","text":"<pre><code>delete_mode(mode_number)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalData.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.ModalDataList","title":"ModalDataList","text":"<p>               Bases: <code>list</code></p>"},{"location":"api/datastructure/#metadata","title":"Metadata","text":""},{"location":"api/datastructure/#pydvma.datastructure.MetaData","title":"MetaData","text":""},{"location":"api/datastructure/#pydvma.datastructure.MetaData-attributes","title":"Attributes","text":""},{"location":"api/datastructure/#pydvma.datastructure.MetaData.units","title":"units  <code>instance-attribute</code>","text":"<pre><code>units = units\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.MetaData.channel_cal_factors","title":"channel_cal_factors  <code>instance-attribute</code>","text":"<pre><code>channel_cal_factors = None\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.MetaData.tf_cal_factors","title":"tf_cal_factors  <code>instance-attribute</code>","text":"<pre><code>tf_cal_factors = None\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.MetaData.timestamp","title":"timestamp  <code>instance-attribute</code>","text":"<pre><code>timestamp = t\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.MetaData.timestring","title":"timestring  <code>instance-attribute</code>","text":"<pre><code>timestring = '_' + str(year) + '_' + str(month) + '_' + str(day) + '_at_' + str(hour) + '_' + str(minute) + '_' + str(second)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.MetaData-functions","title":"Functions","text":""},{"location":"api/datastructure/#pydvma.datastructure.MetaData.__init__","title":"__init__","text":"<pre><code>__init__(units=None, channel_cal_factors=None, tf_cal_factors=None, test_name=None)\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.MetaData.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre>"},{"location":"api/datastructure/#pydvma.datastructure.MetaDataList","title":"MetaDataList","text":"<p>               Bases: <code>list</code></p>"},{"location":"api/file/","title":"File Operations Module","text":"<p>Functions for importing, exporting, and saving data in various formats.</p>"},{"location":"api/file/#load-and-save","title":"Load and Save","text":""},{"location":"api/file/#pydvma.file.load_data","title":"load_data","text":"<pre><code>load_data(parent=None, filename=None)\n</code></pre> <p>Loads dataset from filename, or displays a dialog if no argument provided.</p>"},{"location":"api/file/#pydvma.file.save_data","title":"save_data","text":"<pre><code>save_data(dataset, parent=None, filename=None, overwrite_without_prompt=False)\n</code></pre> <p>Saves dataset class to file 'filename.npy', or provides dialog if no filename provided.</p> <p>Parameters:</p> <ul> <li> <code>dataset</code>               (<code>DataSet</code>)           \u2013            <p>An object of the class DataSet</p> </li> <li> <code>parent</code>               (<code>optional</code>, default:                   <code>None</code> )           \u2013            <p>Parent widget for file dialog</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Output filename, dialog shown if not provided</p> </li> <li> <code>overwrite_without_prompt</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite without asking</p> </li> </ul>"},{"location":"api/file/#pydvma.file.save_fig","title":"save_fig","text":"<pre><code>save_fig(plot, parent=None, figsize=None, filename=None, overwrite_without_prompt=False)\n</code></pre> <p>Saves figure to file 'filename.png' and 'filename.pdf', or provides dialog if no filename provided.</p> <p>Parameters:</p> <ul> <li> <code>plot</code>               (<code>PlotData or Figure</code>)           \u2013            <p>A PlotData object or matplotlib Figure object</p> </li> <li> <code>parent</code>               (<code>optional</code>, default:                   <code>None</code> )           \u2013            <p>Parent widget for file dialog</p> </li> <li> <code>figsize</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>Tuple for figure size</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Output filename, dialog shown if not provided</p> </li> <li> <code>overwrite_without_prompt</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite without asking</p> </li> </ul>"},{"location":"api/file/#export-functions","title":"Export Functions","text":""},{"location":"api/file/#pydvma.file.export_to_matlab","title":"export_to_matlab","text":"<pre><code>export_to_matlab(dataset, parent=None, filename=None, overwrite_without_prompt=False)\n</code></pre> <p>Exports dataset class to file 'filename.mat', or provides dialog if no filename provided.</p> <p>Saved file can be loaded directly in Matlab as set of arrays.</p> <p>Parameters:</p> <ul> <li> <code>dataset</code>               (<code>DataSet</code>)           \u2013            <p>An object of the class DataSet</p> </li> <li> <code>parent</code>               (<code>optional</code>, default:                   <code>None</code> )           \u2013            <p>Parent widget for file dialog</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Output filename, dialog shown if not provided</p> </li> <li> <code>overwrite_without_prompt</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite without asking</p> </li> </ul>"},{"location":"api/file/#pydvma.file.export_to_matlab_jwlogger","title":"export_to_matlab_jwlogger","text":"<pre><code>export_to_matlab_jwlogger(dataset, parent=None, filename=None, overwrite_without_prompt=False)\n</code></pre> <p>Exports dataset class to file 'filename.mat', or provides dialog if no filename provided.</p> <p>Saved file is compatible with Jim Woodhouse logger file format.</p> <p>Parameters:</p> <ul> <li> <code>dataset</code>               (<code>DataSet</code>)           \u2013            <p>An object of the class DataSet</p> </li> <li> <code>parent</code>               (<code>optional</code>, default:                   <code>None</code> )           \u2013            <p>Parent widget for file dialog</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Output filename, dialog shown if not provided</p> </li> <li> <code>overwrite_without_prompt</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite without asking</p> </li> </ul>"},{"location":"api/file/#pydvma.file.export_to_csv","title":"export_to_csv","text":"<pre><code>export_to_csv(data_list, parent=None, filename=None, overwrite_without_prompt=False)\n</code></pre> <p>Exports data to file 'filename.csv', or provides dialog if no filename provided.</p> <p>Saved file is *.csv</p> <p>Parameters:</p> <ul> <li> <code>data_list</code>               (<code>TimeDataList, FreqDataList, or TfDataList</code>)           \u2013            <p>Data list to export</p> </li> <li> <code>parent</code>               (<code>optional</code>, default:                   <code>None</code> )           \u2013            <p>Parent widget for file dialog</p> </li> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Output filename, dialog shown if not provided</p> </li> <li> <code>overwrite_without_prompt</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite without asking</p> </li> </ul>"},{"location":"api/file/#import-functions","title":"Import Functions","text":""},{"location":"api/file/#pydvma.file.import_from_matlab_jwlogger","title":"import_from_matlab_jwlogger","text":"<pre><code>import_from_matlab_jwlogger(filename=None)\n</code></pre> <p>Imports dataset class from file 'filename.mat', or provides dialog if no filename provided.</p> <p>Saved file is compatible with Jim Woodhouse logger file format.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Input filename, dialog shown if not provided</p> </li> </ul>"},{"location":"api/gui/","title":"GUI Module","text":"<p>Graphical user interface components for interactive data logging and analysis.</p>"},{"location":"api/gui/#main-logger-class","title":"Main Logger Class","text":""},{"location":"api/gui/#pydvma.gui.Logger","title":"Logger","text":""},{"location":"api/gui/#pydvma.gui.Logger-attributes","title":"Attributes","text":""},{"location":"api/gui/#pydvma.gui.Logger.settings","title":"settings  <code>instance-attribute</code>","text":"<pre><code>settings = settings\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.test_name","title":"test_name  <code>instance-attribute</code>","text":"<pre><code>test_name = test_name\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.dataset","title":"dataset  <code>instance-attribute</code>","text":"<pre><code>dataset = dataset\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.default_window","title":"default_window  <code>instance-attribute</code>","text":"<pre><code>default_window = default_window\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.current_view","title":"current_view  <code>instance-attribute</code>","text":"<pre><code>current_view = 'Time'\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.N_frames","title":"N_frames  <code>instance-attribute</code>","text":"<pre><code>N_frames = 1\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.overlap","title":"overlap  <code>instance-attribute</code>","text":"<pre><code>overlap = 0.5\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.iw_fft_power","title":"iw_fft_power  <code>instance-attribute</code>","text":"<pre><code>iw_fft_power = 0\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.iw_tf_power","title":"iw_tf_power  <code>instance-attribute</code>","text":"<pre><code>iw_tf_power = 0\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.legend_loc","title":"legend_loc  <code>instance-attribute</code>","text":"<pre><code>legend_loc = 'lower right'\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_coherence","title":"show_coherence  <code>instance-attribute</code>","text":"<pre><code>show_coherence = True\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_data","title":"show_data  <code>instance-attribute</code>","text":"<pre><code>show_data = True\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.coherence_plot_type","title":"coherence_plot_type  <code>instance-attribute</code>","text":"<pre><code>coherence_plot_type = 'linear'\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.xlinlog","title":"xlinlog  <code>instance-attribute</code>","text":"<pre><code>xlinlog = 'linear'\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.plot_type","title":"plot_type  <code>instance-attribute</code>","text":"<pre><code>plot_type = None\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.freq_range","title":"freq_range  <code>instance-attribute</code>","text":"<pre><code>freq_range = [0, inf]\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.auto_xy","title":"auto_xy  <code>instance-attribute</code>","text":"<pre><code>auto_xy = 'xy'\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.sets","title":"sets  <code>instance-attribute</code>","text":"<pre><code>sets = 'all'\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.channels","title":"channels  <code>instance-attribute</code>","text":"<pre><code>channels = 'all'\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.last_action","title":"last_action  <code>instance-attribute</code>","text":"<pre><code>last_action = None\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.iw_power","title":"iw_power  <code>instance-attribute</code>","text":"<pre><code>iw_power = 0\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.selected_channels","title":"selected_channels  <code>instance-attribute</code>","text":"<pre><code>selected_channels = []\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.flag_scaling","title":"flag_scaling  <code>instance-attribute</code>","text":"<pre><code>flag_scaling = False\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.message_time","title":"message_time  <code>instance-attribute</code>","text":"<pre><code>message_time = 0\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.flag_log_and_replace","title":"flag_log_and_replace  <code>instance-attribute</code>","text":"<pre><code>flag_log_and_replace = False\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.flag_output","title":"flag_output  <code>instance-attribute</code>","text":"<pre><code>flag_output = False\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.message_timer","title":"message_timer  <code>instance-attribute</code>","text":"<pre><code>message_timer = QTimer()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.stream_check_timer","title":"stream_check_timer  <code>instance-attribute</code>","text":"<pre><code>stream_check_timer = QTimer()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.levels_timer","title":"levels_timer  <code>instance-attribute</code>","text":"<pre><code>levels_timer = QTimer()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = ''\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.t0_clipped","title":"t0_clipped  <code>instance-attribute</code>","text":"<pre><code>t0_clipped = 0\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.fn_in_range","title":"fn_in_range  <code>instance-attribute</code>","text":"<pre><code>fn_in_range = array([])\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.output_signal_settings","title":"output_signal_settings  <code>instance-attribute</code>","text":"<pre><code>output_signal_settings = Output_Signal_Settings(type='None', amp=0, f1=0, f2=0)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.window","title":"window  <code>instance-attribute</code>","text":"<pre><code>window = QWidget()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger-functions","title":"Functions","text":""},{"location":"api/gui/#pydvma.gui.Logger.__init__","title":"__init__","text":"<pre><code>__init__(settings=None, test_name=None, default_window=None, output_signal_settings=None, dataset=None)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_layout_main","title":"setup_layout_main","text":"<pre><code>setup_layout_main()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_figure","title":"setup_frame_figure","text":"<pre><code>setup_frame_figure()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_input","title":"setup_frame_input","text":"<pre><code>setup_frame_input()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_message","title":"setup_frame_message","text":"<pre><code>setup_frame_message()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_save","title":"setup_frame_save","text":"<pre><code>setup_frame_save()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_axes","title":"setup_frame_axes","text":"<pre><code>setup_frame_axes()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_plot_details","title":"setup_frame_plot_details","text":"<pre><code>setup_frame_plot_details()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools","title":"setup_frame_tools","text":"<pre><code>setup_frame_tools()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_selection","title":"setup_frame_tools_selection","text":"<pre><code>setup_frame_tools_selection()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_time_domain","title":"setup_frame_tools_time_domain","text":"<pre><code>setup_frame_tools_time_domain()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_fft","title":"setup_frame_tools_fft","text":"<pre><code>setup_frame_tools_fft()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_tf","title":"setup_frame_tools_tf","text":"<pre><code>setup_frame_tools_tf()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_scaling","title":"setup_frame_tools_scaling","text":"<pre><code>setup_frame_tools_scaling()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_mode_fitting","title":"setup_frame_tools_mode_fitting","text":"<pre><code>setup_frame_tools_mode_fitting()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_settings","title":"setup_frame_tools_settings","text":"<pre><code>setup_frame_tools_settings()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_generate_output","title":"setup_frame_tools_generate_output","text":"<pre><code>setup_frame_tools_generate_output()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_edit_dataset","title":"setup_frame_tools_edit_dataset","text":"<pre><code>setup_frame_tools_edit_dataset()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_sonogram","title":"setup_frame_tools_sonogram","text":"<pre><code>setup_frame_tools_sonogram()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.setup_frame_tools_save_export","title":"setup_frame_tools_save_export","text":"<pre><code>setup_frame_tools_save_export()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_frame_tools","title":"update_frame_tools","text":"<pre><code>update_frame_tools()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show","title":"show","text":"<pre><code>show()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.close","title":"close","text":"<pre><code>close()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.start_stream","title":"start_stream","text":"<pre><code>start_stream()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_message","title":"show_message","text":"<pre><code>show_message(message, b='ok')\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.hide_message","title":"hide_message","text":"<pre><code>hide_message()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_message_timer","title":"show_message_timer","text":"<pre><code>show_message_timer()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.check_stream","title":"check_stream","text":"<pre><code>check_stream()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_levels","title":"show_levels","text":"<pre><code>show_levels()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.button_clicked_osc","title":"button_clicked_osc","text":"<pre><code>button_clicked_osc()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.button_clicked_log_data","title":"button_clicked_log_data","text":"<pre><code>button_clicked_log_data()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.add_logged_data","title":"add_logged_data","text":"<pre><code>add_logged_data(d)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.cancel_logging","title":"cancel_logging","text":"<pre><code>cancel_logging()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.delete_last_data","title":"delete_last_data","text":"<pre><code>delete_last_data()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.reset_data","title":"reset_data","text":"<pre><code>reset_data()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.load_data","title":"load_data","text":"<pre><code>load_data()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.save_data","title":"save_data","text":"<pre><code>save_data()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.save_fig","title":"save_fig","text":"<pre><code>save_fig()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.xmin","title":"xmin","text":"<pre><code>xmin()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.xmax","title":"xmax","text":"<pre><code>xmax()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.ymin","title":"ymin","text":"<pre><code>ymin()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.ymax","title":"ymax","text":"<pre><code>ymax()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.auto_x","title":"auto_x","text":"<pre><code>auto_x()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.auto_y","title":"auto_y","text":"<pre><code>auto_y()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_axes_values","title":"update_axes_values","text":"<pre><code>update_axes_values(axes)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_modal_message","title":"update_modal_message","text":"<pre><code>update_modal_message(axes)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.legend_left","title":"legend_left","text":"<pre><code>legend_left()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.legend_right","title":"legend_right","text":"<pre><code>legend_right()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.legend_onoff","title":"legend_onoff","text":"<pre><code>legend_onoff()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_figure","title":"update_figure","text":"<pre><code>update_figure()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_selected_channels","title":"update_selected_channels","text":"<pre><code>update_selected_channels(_)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.select_all_data","title":"select_all_data","text":"<pre><code>select_all_data()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.select_no_data","title":"select_no_data","text":"<pre><code>select_no_data()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_set_only","title":"show_set_only","text":"<pre><code>show_set_only()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_chan_only","title":"show_chan_only","text":"<pre><code>show_chan_only()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.next_chans","title":"next_chans","text":"<pre><code>next_chans()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.prev_chans","title":"prev_chans","text":"<pre><code>prev_chans()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.co_min","title":"co_min","text":"<pre><code>co_min()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.co_max","title":"co_max","text":"<pre><code>co_max()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.freq_min","title":"freq_min","text":"<pre><code>freq_min()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.freq_max","title":"freq_max","text":"<pre><code>freq_max()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_co_axes_values","title":"update_co_axes_values","text":"<pre><code>update_co_axes_values(axes)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.data_toggle","title":"data_toggle","text":"<pre><code>data_toggle()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.coherence_toggle","title":"coherence_toggle","text":"<pre><code>coherence_toggle()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.select_xlinlog","title":"select_xlinlog","text":"<pre><code>select_xlinlog()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.switch_view","title":"switch_view","text":"<pre><code>switch_view(new_view_text)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.select_view","title":"select_view","text":"<pre><code>select_view()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.hide_plot_details","title":"hide_plot_details","text":"<pre><code>hide_plot_details()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_plot_details_with_coherence","title":"show_plot_details_with_coherence","text":"<pre><code>show_plot_details_with_coherence()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_plot_details_with_nqyuist","title":"show_plot_details_with_nqyuist","text":"<pre><code>show_plot_details_with_nqyuist()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_plot_details_basic","title":"show_plot_details_basic","text":"<pre><code>show_plot_details_basic()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.hide_all_tools","title":"hide_all_tools","text":"<pre><code>hide_all_tools()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.select_tool","title":"select_tool","text":"<pre><code>select_tool()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.apply_settings","title":"apply_settings","text":"<pre><code>apply_settings()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.show_available_devices","title":"show_available_devices","text":"<pre><code>show_available_devices()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_selected_set","title":"update_selected_set","text":"<pre><code>update_selected_set()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_data_summary","title":"update_data_summary","text":"<pre><code>update_data_summary()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.delete_data_type","title":"delete_data_type","text":"<pre><code>delete_data_type()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.delete_data_set","title":"delete_data_set","text":"<pre><code>delete_data_set()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.log_and_replace","title":"log_and_replace","text":"<pre><code>log_and_replace()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.update_output","title":"update_output","text":"<pre><code>update_output()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.create_output_signal","title":"create_output_signal","text":"<pre><code>create_output_signal()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.preview_output","title":"preview_output","text":"<pre><code>preview_output()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.start_output","title":"start_output","text":"<pre><code>start_output()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.clean_impulse","title":"clean_impulse","text":"<pre><code>clean_impulse()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.undo_last_action","title":"undo_last_action","text":"<pre><code>undo_last_action()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.calc_fft","title":"calc_fft","text":"<pre><code>calc_fft()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.select_averaging_type","title":"select_averaging_type","text":"<pre><code>select_averaging_type()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.refresh_Nframes_text","title":"refresh_Nframes_text","text":"<pre><code>refresh_Nframes_text()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.refresh_Nframes_slider","title":"refresh_Nframes_slider","text":"<pre><code>refresh_Nframes_slider()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.refresh_test_name","title":"refresh_test_name","text":"<pre><code>refresh_test_name()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.refresh_test_name2","title":"refresh_test_name2","text":"<pre><code>refresh_test_name2()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.calc_tf","title":"calc_tf","text":"<pre><code>calc_tf()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.calc_tf_av","title":"calc_tf_av","text":"<pre><code>calc_tf_av(b)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.xiw","title":"xiw","text":"<pre><code>xiw()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.diw","title":"diw","text":"<pre><code>diw()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.xiwp","title":"xiwp","text":"<pre><code>xiwp(power)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.undo_scaling","title":"undo_scaling","text":"<pre><code>undo_scaling()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.best_match","title":"best_match","text":"<pre><code>best_match()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.fit_mode","title":"fit_mode","text":"<pre><code>fit_mode()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.freq_min2","title":"freq_min2","text":"<pre><code>freq_min2()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.freq_max2","title":"freq_max2","text":"<pre><code>freq_max2()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.accept_mode","title":"accept_mode","text":"<pre><code>accept_mode()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.reject_mode","title":"reject_mode","text":"<pre><code>reject_mode()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.view_mode_summary","title":"view_mode_summary","text":"<pre><code>view_mode_summary()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.view_modal_reconstruction","title":"view_modal_reconstruction","text":"<pre><code>view_modal_reconstruction()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.refresh_sono_N_frames_slider","title":"refresh_sono_N_frames_slider","text":"<pre><code>refresh_sono_N_frames_slider()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.refresh_sono_N_frames_text","title":"refresh_sono_N_frames_text","text":"<pre><code>refresh_sono_N_frames_text()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.calc_sono","title":"calc_sono","text":"<pre><code>calc_sono()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.calc_damping","title":"calc_damping","text":"<pre><code>calc_damping()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.import_jwlogger","title":"import_jwlogger","text":"<pre><code>import_jwlogger()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.export_jwlogger","title":"export_jwlogger","text":"<pre><code>export_jwlogger()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.export_matlab","title":"export_matlab","text":"<pre><code>export_matlab()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.Logger.export_csv","title":"export_csv","text":"<pre><code>export_csv()\n</code></pre>"},{"location":"api/gui/#window-classes","title":"Window Classes","text":"<p>Note</p> <p>The GUI module is primarily intended for interactive use through the Logger interface. Most users will instantiate <code>Logger(settings)</code> rather than using these classes directly.</p>"},{"location":"api/gui/#pydvma.gui.PreviewWindow","title":"PreviewWindow","text":""},{"location":"api/gui/#pydvma.gui.PreviewWindow-attributes","title":"Attributes","text":""},{"location":"api/gui/#pydvma.gui.PreviewWindow.preview_window","title":"preview_window  <code>instance-attribute</code>","text":"<pre><code>preview_window = QWidget()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.PreviewWindow.fig","title":"fig  <code>instance-attribute</code>","text":"<pre><code>fig = Figure(figsize=(9, 5), dpi=100)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.PreviewWindow.canvas","title":"canvas  <code>instance-attribute</code>","text":"<pre><code>canvas = FigureCanvas(fig)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.PreviewWindow.toolbar","title":"toolbar  <code>instance-attribute</code>","text":"<pre><code>toolbar = NavigationToolbar2QT(canvas, None)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.PreviewWindow.p","title":"p  <code>instance-attribute</code>","text":"<pre><code>p = PlotData(canvas=canvas, fig=fig)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.PreviewWindow.label_figure","title":"label_figure  <code>instance-attribute</code>","text":"<pre><code>label_figure = boldLabel(title)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.PreviewWindow.layout_figure","title":"layout_figure  <code>instance-attribute</code>","text":"<pre><code>layout_figure = QVBoxLayout()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.DampingFitWindow","title":"DampingFitWindow","text":""},{"location":"api/gui/#pydvma.gui.DampingFitWindow-attributes","title":"Attributes","text":""},{"location":"api/gui/#pydvma.gui.DampingFitWindow.window","title":"window  <code>instance-attribute</code>","text":"<pre><code>window = QWidget()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.DampingFitWindow.fig","title":"fig  <code>instance-attribute</code>","text":"<pre><code>fig = Figure(figsize=(9, 6), dpi=100)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.DampingFitWindow.canvas","title":"canvas  <code>instance-attribute</code>","text":"<pre><code>canvas = FigureCanvas(fig)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.DampingFitWindow.toolbar","title":"toolbar  <code>instance-attribute</code>","text":"<pre><code>toolbar = NavigationToolbar2QT(canvas, None)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.DampingFitWindow.label_figure","title":"label_figure  <code>instance-attribute</code>","text":"<pre><code>label_figure = boldLabel(title)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.DampingFitWindow.ax","title":"ax  <code>instance-attribute</code>","text":"<pre><code>ax = add_subplot(111)\n</code></pre>"},{"location":"api/gui/#pydvma.gui.DampingFitWindow.layout_figure","title":"layout_figure  <code>instance-attribute</code>","text":"<pre><code>layout_figure = QVBoxLayout()\n</code></pre>"},{"location":"api/gui/#pydvma.gui.DampingFitWindow-functions","title":"Functions","text":""},{"location":"api/gui/#pydvma.gui.DampingFitWindow.plot_fits","title":"plot_fits","text":"<pre><code>plot_fits(fit_data)\n</code></pre>"},{"location":"api/modal/","title":"Modal Analysis Module","text":"<p>Modal analysis tools for mode fitting and modal parameter extraction.</p>"},{"location":"api/modal/#pydvma.modal","title":"modal","text":"<p>Created on Mon Aug 19 17:29:30 2019</p> <p>@author: tb267</p>"},{"location":"api/modal/#pydvma.modal-attributes","title":"Attributes","text":""},{"location":"api/modal/#pydvma.modal.MESSAGE","title":"MESSAGE  <code>module-attribute</code>","text":"<pre><code>MESSAGE = ''\n</code></pre>"},{"location":"api/modal/#pydvma.modal-functions","title":"Functions","text":""},{"location":"api/modal/#pydvma.modal.f_3dB","title":"f_3dB","text":"<pre><code>f_3dB(f, G0)\n</code></pre>"},{"location":"api/modal/#pydvma.modal.modal_fit_single_channel","title":"modal_fit_single_channel","text":"<pre><code>modal_fit_single_channel(tf_data, freq_range=None, channel=0, measurement_type='acc')\n</code></pre> <p>Fit modal parameters for a single mode to data within specified freq_range</p>"},{"location":"api/modal/#pydvma.modal.f_TF","title":"f_TF","text":"<pre><code>f_TF(x, f, measurement_type)\n</code></pre>"},{"location":"api/modal/#pydvma.modal.f_residual","title":"f_residual","text":"<pre><code>f_residual(x, f, G0, measurement_type)\n</code></pre>"},{"location":"api/modal/#pydvma.modal.f_TF_all_channels","title":"f_TF_all_channels","text":"<pre><code>f_TF_all_channels(x, f, measurement_type)\n</code></pre>"},{"location":"api/modal/#pydvma.modal.f_residual_all_channels","title":"f_residual_all_channels","text":"<pre><code>f_residual_all_channels(x, f, G0, measurement_type)\n</code></pre>"},{"location":"api/modal/#pydvma.modal.modal_fit_all_channels","title":"modal_fit_all_channels","text":"<pre><code>modal_fit_all_channels(tf_data_list, freq_range=None, measurement_type='acc')\n</code></pre> <p>Fit modal parameters for a single mode to data within specified freq_range.</p> <p>Assumes all tf_data in tf_data_list have same frequency axes</p>"},{"location":"api/modal/#pydvma.modal.unpack","title":"unpack","text":"<pre><code>unpack(x)\n</code></pre>"},{"location":"api/modal/#pydvma.modal.unpack_matrix","title":"unpack_matrix","text":"<pre><code>unpack_matrix(X)\n</code></pre>"},{"location":"api/modal/#pydvma.modal.pack","title":"pack","text":"<pre><code>pack(fn, zn, an, pn, rk, rm)\n</code></pre>"},{"location":"api/modal/#pydvma.modal.reconstruct_transfer_function","title":"reconstruct_transfer_function","text":"<pre><code>reconstruct_transfer_function(modal_data, f, measurement_type='acc')\n</code></pre> <p>Reconstructs transfer functions from modal_data and returns TfData object</p>"},{"location":"api/modal/#pydvma.modal.reconstruct_transfer_function_global","title":"reconstruct_transfer_function_global","text":"<pre><code>reconstruct_transfer_function_global(modal_data, f, measurement_type='acc')\n</code></pre> <p>Reconstructs transfer functions from modal_data and returns TfData object</p>"},{"location":"api/plotting/","title":"Plotting Module","text":"<p>Interactive plotting tools and utilities.</p> <p>Note</p> <p>The plotting module provides the PlotData class used internally by the GUI. For custom plotting, it's recommended to use matplotlib directly as shown in the Plotting Guide.</p>"},{"location":"api/plotting/#pydvma.plotting","title":"plotting","text":"<p>Created on Tue Aug 28 19:04:14 2018</p> <p>@author: tb267</p>"},{"location":"api/plotting/#pydvma.plotting-attributes","title":"Attributes","text":""},{"location":"api/plotting/#pydvma.plotting.LINE_ALPHA","title":"LINE_ALPHA  <code>module-attribute</code>","text":"<pre><code>LINE_ALPHA = 0.9\n</code></pre>"},{"location":"api/plotting/#pydvma.plotting-classes","title":"Classes","text":""},{"location":"api/plotting/#pydvma.plotting.PlotSonoData","title":"PlotSonoData","text":""},{"location":"api/plotting/#pydvma.plotting.PlotSonoData-attributes","title":"Attributes","text":"fig <code>instance-attribute</code> \u00b6 <pre><code>fig = fig\n</code></pre> canvas <code>instance-attribute</code> \u00b6 <pre><code>canvas = canvas\n</code></pre> ax <code>instance-attribute</code> \u00b6 <pre><code>ax = subplots()\n</code></pre>"},{"location":"api/plotting/#pydvma.plotting.PlotSonoData-functions","title":"Functions","text":"update \u00b6 <pre><code>update(sono_data_list, n_set=0, n_chan=0)\n</code></pre>"},{"location":"api/plotting/#pydvma.plotting.PlotData","title":"PlotData","text":""},{"location":"api/plotting/#pydvma.plotting.PlotData-attributes","title":"Attributes","text":"fig <code>instance-attribute</code> \u00b6 <pre><code>fig = fig\n</code></pre> canvas <code>instance-attribute</code> \u00b6 <pre><code>canvas = canvas\n</code></pre> ax <code>instance-attribute</code> \u00b6 <pre><code>ax = subplots()\n</code></pre> ax2 <code>instance-attribute</code> \u00b6 <pre><code>ax2 = twinx()\n</code></pre> line_listbyset <code>instance-attribute</code> \u00b6 <pre><code>line_listbyset = []\n</code></pre> line2_listbyset <code>instance-attribute</code> \u00b6 <pre><code>line2_listbyset = []\n</code></pre> pcolor_sono <code>instance-attribute</code> \u00b6 <pre><code>pcolor_sono = None\n</code></pre> visibility <code>instance-attribute</code> \u00b6 <pre><code>visibility = True\n</code></pre>"},{"location":"api/plotting/#pydvma.plotting.PlotData-functions","title":"Functions","text":"update \u00b6 <pre><code>update(data_list, sets='all', channels='all', xlinlog='linear', show_coherence=True, plot_type=None, coherence_plot_type='linear', freq_range=None, auto_xy='xyc')\n</code></pre> update_legend \u00b6 <pre><code>update_legend(loc='lower right', draggable=False)\n</code></pre> auto_x \u00b6 <pre><code>auto_x()\n</code></pre> auto_y \u00b6 <pre><code>auto_y()\n</code></pre> channel_select \u00b6 <pre><code>channel_select(event)\n</code></pre> get_selected_channels \u00b6 <pre><code>get_selected_channels()\n</code></pre> set_selected_channels \u00b6 <pre><code>set_selected_channels(s)\n</code></pre> update_sonogram \u00b6 <pre><code>update_sonogram(sono_data_list, n_set, n_chan, db_range=60, auto_xy='xy')\n</code></pre>"},{"location":"examples/advanced/","title":"Advanced Examples","text":"<p>More advanced usage examples and workflows.</p>"},{"location":"examples/advanced/#complete-experimental-modal-analysis","title":"Complete Experimental Modal Analysis","text":"<p>See the Modal Analysis page for a complete EMA workflow example.</p>"},{"location":"examples/advanced/#custom-signal-processing","title":"Custom Signal Processing","text":"<pre><code>import pydvma as dvma\nimport numpy as np\nfrom scipy import signal\n\n# Record data\nsettings = dvma.MySettings()\ndataset = dvma.log_data(settings)\ntime_data = dataset.time_data_list[0]\n\n# Design custom filter\nsos = signal.butter(4, [50, 500], 'bandpass',\n                    fs=settings.fs, output='sos')\n\n# Apply filter\nfiltered = signal.sosfiltfilt(sos, time_data.time_data, axis=0)\n\n# Analyze filtered data\nimport copy\ntime_data_filtered = copy.copy(time_data)\ntime_data_filtered.time_data = filtered\n\nfreq_data = dvma.calculate_fft(time_data_filtered)\n</code></pre>"},{"location":"examples/advanced/#batch-processing-multiple-files","title":"Batch Processing Multiple Files","text":"<pre><code>import pydvma as dvma\nimport os\n\n# Process all measurements in a directory\ndata_dir = 'measurements'\nfiles = [f for f in os.listdir(data_dir) if f.endswith('.pkl')]\n\nresults = []\nfor filename in files:\n    # Load data\n    with open(os.path.join(data_dir, filename), 'rb') as f:\n        time_data = pickle.load(f)\n\n    # Analyze\n    freq_data = dvma.calculate_fft(time_data)\n    tf_data = dvma.calculate_tf(time_data, ch_in=0)\n\n    # Store results\n    results.append({\n        'filename': filename,\n        'freq_data': freq_data,\n        'tf_data': tf_data\n    })\n</code></pre>"},{"location":"examples/advanced/#integration-with-other-tools","title":"Integration with Other Tools","text":"<pre><code>import pydvma as dvma\nimport pandas as pd\n\n# Convert to pandas DataFrame for analysis\ntime_data = dataset.time_data_list[0]\ndf = pd.DataFrame(\n    time_data.time_data,\n    index=time_data.time_axis,\n    columns=[f'Channel_{i}' for i in range(time_data.time_data.shape[1])]\n)\n\n# Use pandas tools\nprint(df.describe())\ndf.plot()\n</code></pre>"},{"location":"examples/basic/","title":"Basic Examples","text":"<p>Collection of basic examples for common tasks.</p>"},{"location":"examples/basic/#example-1-simple-measurement-and-fft","title":"Example 1: Simple Measurement and FFT","text":"<pre><code>import pydvma as dvma\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Setup\nsettings = dvma.MySettings()\nsettings.fs = 10000\nsettings.stored_time = 2.0\nsettings.channels = 1\n\n# Record\ndataset = dvma.log_data(settings, test_name=\"example_01\")\ntime_data = dataset.time_data_list[0]\n\n# Calculate FFT\nfreq_data = dvma.calculate_fft(time_data, window='hann')\n\n# Plot\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))\n\nax1.plot(time_data.time_axis, time_data.time_data[:, 0])\nax1.set_xlabel('Time (s)')\nax1.set_ylabel('Amplitude')\nax1.set_title('Time Domain')\nax1.grid(True)\n\nax2.semilogy(freq_data.freq_axis, np.abs(freq_data.freq_data[:, 0]))\nax2.set_xlabel('Frequency (Hz)')\nax2.set_ylabel('Magnitude')\nax2.set_title('Frequency Domain')\nax2.set_xlim([0, 2000])\nax2.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/basic/#example-2-transfer-function-measurement","title":"Example 2: Transfer Function Measurement","text":"<pre><code>import pydvma as dvma\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Setup for 2-channel measurement\nsettings = dvma.MySettings()\nsettings.fs = 10000\nsettings.stored_time = 2.0\nsettings.channels = 2  # Channel 0: input, Channel 1: output\n\n# Record\ndataset = dvma.log_data(settings, test_name=\"tf_measurement\")\ntime_data = dataset.time_data_list[0]\n\n# Calculate transfer function\ntf_data = dvma.calculate_tf(time_data, ch_in=0, window='hann',\n                             N_frames=4, overlap=0.5)\n\n# Plot\nf = tf_data.freq_axis\nH = tf_data.tf_data[:, 0]\ncoh = tf_data.tf_coherence[:, 0]\n\nfig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 10))\n\n# Magnitude\nax1.loglog(f, np.abs(H))\nax1.set_ylabel('|H(f)|')\nax1.set_title('FRF Magnitude')\nax1.grid(True, which='both')\n\n# Phase\nax2.semilogx(f, np.angle(H, deg=True))\nax2.set_ylabel('Phase (deg)')\nax2.set_title('FRF Phase')\nax2.grid(True)\n\n# Coherence\nax3.semilogx(f, coh)\nax3.set_xlabel('Frequency (Hz)')\nax3.set_ylabel('Coherence')\nax3.set_ylim([0, 1])\nax3.set_title('Coherence')\nax3.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/basic/#example-3-impact-test-with-averaging","title":"Example 3: Impact Test with Averaging","text":"<pre><code>import pydvma as dvma\nimport numpy as np\n\n# Setup\nsettings = dvma.MySettings()\nsettings.fs = 10000\nsettings.stored_time = 1.0\nsettings.channels = 2\nsettings.pretrig_samples = 1000\n\n# Collect multiple impacts\ntime_data_list = dvma.TimeDataList()\nn_impacts = 5\n\nfor i in range(n_impacts):\n    input(f\"Press Enter for impact {i+1}/{n_impacts}...\")\n    data = dvma.log_data(settings, test_name=f\"impact_{i}\")\n    time_data_list.append(data.time_data_list[0])\n\n# Calculate averaged transfer function\ntf_data = dvma.calculate_tf_averaged(time_data_list, ch_in=0)\n\n# Results\nprint(f\"Averaged {len(time_data_list)} measurements\")\nprint(f\"Average coherence: {np.mean(tf_data.tf_coherence):.3f}\")\n</code></pre>"},{"location":"examples/basic/#example-4-sonogram-analysis","title":"Example 4: Sonogram Analysis","text":"<pre><code>import pydvma as dvma\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Record data\nsettings = dvma.MySettings()\nsettings.fs = 10000\nsettings.stored_time = 5.0\ndataset = dvma.log_data(settings, test_name=\"sono_test\")\ntime_data = dataset.time_data_list[0]\n\n# Calculate sonogram\nsono_data = dvma.calculate_sonogram(time_data, nperseg=512, noverlap=256)\n\n# Plot\nplt.figure(figsize=(12, 6))\nplt.pcolormesh(sono_data.time_axis,\n               sono_data.freq_axis,\n               20*np.log10(np.abs(sono_data.sono_data[:, :, 0])),\n               shading='gouraud',\n               cmap='viridis')\nplt.ylabel('Frequency (Hz)')\nplt.xlabel('Time (s)')\nplt.colorbar(label='Magnitude (dB)')\nplt.ylim([0, 2000])\nplt.title('Sonogram')\nplt.show()\n</code></pre>"},{"location":"examples/basic/#example-5-modal-analysis-from-impact","title":"Example 5: Modal Analysis from Impact","text":"<pre><code>import pydvma as dvma\nimport numpy as np\n\n# Record impact response\nsettings = dvma.MySettings()\nsettings.fs = 10000\nsettings.stored_time = 2.0\nsettings.channels = 2\nsettings.pretrig_samples = 1000\n\ndataset = dvma.log_data(settings, test_name=\"modal_test\")\ntime_data = dataset.time_data_list[0]\n\n# Extract damping from free decay\nfn, Qn, fit_data = dvma.calculate_damping_from_sono(\n    time_data,\n    n_chan=1,\n    nperseg=512\n)\n\n# Display results\nprint(\"Modal Analysis Results:\")\nprint(\"-\" * 40)\nfor i, (f, Q) in enumerate(zip(fn, Qn)):\n    zeta = 1 / (2 * Q)\n    print(f\"Mode {i+1}:\")\n    print(f\"  Natural frequency: {f:.2f} Hz\")\n    print(f\"  Damping ratio: {zeta:.4f}\")\n    print(f\"  Q factor: {Q:.1f}\")\n    print()\n</code></pre>"},{"location":"getting-started/basic-usage/","title":"Basic Usage","text":"<p>This page covers fundamental concepts and common usage patterns in pydvma.</p>"},{"location":"getting-started/basic-usage/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/basic-usage/#data-structure-hierarchy","title":"Data Structure Hierarchy","text":"<p>pydvma uses a hierarchical data structure:</p> <ul> <li>DataSet: Top-level container holding all data</li> <li>TimeData: Time-domain measurements</li> <li>FreqData: Frequency-domain data (from FFT)</li> <li>TfData: Transfer function data</li> <li>SonoData: Sonogram/spectrogram data</li> </ul> <p>Each data type includes: - The data itself - Axis information (time/frequency) - Settings and metadata - Unique identifiers for traceability</p>"},{"location":"getting-started/basic-usage/#settings-object","title":"Settings Object","text":"<p>The <code>MySettings()</code> object controls acquisition and analysis parameters:</p> <pre><code>settings = dvma.MySettings()\n\n# Acquisition settings\nsettings.fs = 10000          # Sampling frequency (Hz)\nsettings.stored_time = 2.0   # Duration (seconds)\nsettings.channels = 2        # Number of channels\nsettings.pretrig_samples = 1000  # Pre-trigger samples\n\n# Device settings\nsettings.device_driver = 'soundcard'  # or 'nidaq'\nsettings.device_index = None  # None for default device\n</code></pre>"},{"location":"getting-started/basic-usage/#working-with-different-data-types","title":"Working with Different Data Types","text":""},{"location":"getting-started/basic-usage/#time-data","title":"Time Data","text":"<pre><code># Access time data from dataset\ntime_data = dataset.time_data_list[0]\n\n# Data components\nt = time_data.time_axis        # Time vector\ny = time_data.time_data        # Signal data (samples x channels)\nfs = time_data.settings.fs     # Sampling frequency\n\n# Channel indexing\nchannel_0 = y[:, 0]  # First channel\nchannel_1 = y[:, 1]  # Second channel\n</code></pre>"},{"location":"getting-started/basic-usage/#frequency-data","title":"Frequency Data","text":"<pre><code># Calculate FFT\nfreq_data = dvma.calculate_fft(time_data, window='hann')\n\n# Data components\nf = freq_data.freq_axis        # Frequency vector\nY = freq_data.freq_data        # Complex frequency data\nmagnitude = np.abs(Y)          # Magnitude spectrum\nphase = np.angle(Y)            # Phase spectrum\n</code></pre>"},{"location":"getting-started/basic-usage/#transfer-function-data","title":"Transfer Function Data","text":"<pre><code># Calculate transfer function (input on channel 0)\ntf_data = dvma.calculate_tf(time_data, ch_in=0, window='hann')\n\n# Data components\nf = tf_data.freq_axis              # Frequency vector\nH = tf_data.tf_data               # Complex transfer function\ncoherence = tf_data.tf_coherence  # Coherence function\n\n# Plot FRF\nmagnitude = np.abs(H[:, 0])\nplt.loglog(f, magnitude)\n</code></pre>"},{"location":"getting-started/basic-usage/#windowing","title":"Windowing","text":"<p>Windows reduce spectral leakage in FFT analysis:</p> <pre><code># No window (rectangular)\nfreq_data = dvma.calculate_fft(time_data, window=None)\n\n# Hann window (good general purpose)\nfreq_data = dvma.calculate_fft(time_data, window='hann')\n\n# Blackman window (better frequency resolution)\nfreq_data = dvma.calculate_fft(time_data, window='blackman')\n</code></pre> <p>Common windows: - <code>None</code> or <code>'boxcar'</code>: Rectangular (no window) - <code>'hann'</code>: Good general purpose - <code>'hamming'</code>: Similar to Hann - <code>'blackman'</code>: Better frequency resolution, more smoothing</p>"},{"location":"getting-started/basic-usage/#averaging","title":"Averaging","text":""},{"location":"getting-started/basic-usage/#frame-averaging-for-better-snr","title":"Frame Averaging for Better SNR","text":"<pre><code># Calculate transfer function with averaging\ntf_data = dvma.calculate_tf(\n    time_data,\n    ch_in=0,\n    window='hann',\n    N_frames=8,      # Average over 8 frames\n    overlap=0.5      # 50% overlap between frames\n)\n</code></pre>"},{"location":"getting-started/basic-usage/#ensemble-averaging","title":"Ensemble Averaging","text":"<p>For repeated measurements (e.g., impact hammer tests):</p> <pre><code># Create list of measurements\ntime_data_list = dvma.TimeDataList()\nfor i in range(10):\n    # Record 10 impacts\n    data = dvma.log_data(settings, test_name=f\"impact_{i}\")\n    time_data_list.append(data.time_data_list[0])\n\n# Calculate averaged transfer function\ntf_data_avg = dvma.calculate_tf_averaged(\n    time_data_list,\n    ch_in=0,\n    window='hann'\n)\n</code></pre>"},{"location":"getting-started/basic-usage/#integration-and-differentiation","title":"Integration and Differentiation","text":"<p>Convert between acceleration, velocity, and displacement:</p> <pre><code># Start with acceleration data\nfreq_data = dvma.calculate_fft(time_data_accel)\n\n# Integrate to velocity (multiply by 1/(i\u03c9))\nfreq_data_vel = dvma.multiply_by_power_of_iw(\n    freq_data,\n    power=-1,\n    channel_list=[0, 1]  # Channels to process\n)\n\n# Integrate again to displacement (multiply by 1/(i\u03c9)\u00b2)\nfreq_data_disp = dvma.multiply_by_power_of_iw(\n    freq_data,\n    power=-2,\n    channel_list=[0, 1]\n)\n\n# Differentiate (multiply by i\u03c9)\nfreq_data_diff = dvma.multiply_by_power_of_iw(\n    freq_data,\n    power=1,\n    channel_list=[0, 1]\n)\n</code></pre>"},{"location":"getting-started/basic-usage/#time-range-selection","title":"Time Range Selection","text":"<p>Analyze specific portions of your data:</p> <pre><code># Define time range\ntime_range = np.array([0.5, 1.5])  # From 0.5s to 1.5s\n\n# Calculate FFT for selected range\nfreq_data = dvma.calculate_fft(time_data, time_range=time_range)\n\n# Works for transfer functions too\ntf_data = dvma.calculate_tf(time_data, ch_in=0, time_range=time_range)\n</code></pre>"},{"location":"getting-started/basic-usage/#best-match-scaling","title":"Best Match Scaling","text":"<p>When comparing multiple datasets, automatically scale them to match:</p> <pre><code># Create list of transfer functions\ntf_list = dvma.TfDataList()\ntf_list.append(tf_data_1)\ntf_list.append(tf_data_2)\ntf_list.append(tf_data_3)\n\n# Get scale factors (relative to set 0, channel 0)\nfactors = dvma.best_match(\n    tf_list,\n    freq_range=[100, 500],  # Frequency range for matching\n    set_ref=0,              # Reference dataset\n    ch_ref=0                # Reference channel\n)\n\n# Apply scaling\nfor i, factor in enumerate(factors):\n    tf_list[i].tf_data *= factor[:, None]\n</code></pre>"},{"location":"getting-started/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about specific tasks in the User Guide</li> <li>Explore Examples for complete workflows</li> <li>Dive into the API Reference for detailed function documentation</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or later (Python 3.13 recommended)</li> <li>Anaconda or Miniconda (recommended for managing dependencies)</li> </ul>"},{"location":"getting-started/installation/#step-1-install-anaconda","title":"Step 1: Install Anaconda","text":"<p>If you don't already have Anaconda installed, download it from:</p> <p>Download Anaconda</p> <p>Follow the installer instructions for your operating system.</p>"},{"location":"getting-started/installation/#step-2-install-pydvma","title":"Step 2: Install pydvma","text":""},{"location":"getting-started/installation/#option-a-quick-installation-recommended","title":"Option A: Quick Installation (Recommended)","text":"<p>Open the Anaconda Prompt (Windows) or terminal (Mac/Linux) and run:</p> <pre><code>conda install numpy scipy jupyter matplotlib pyqtgraph ipympl ipywidgets jupyterlab\npip install sounddevice pydvma\n</code></pre>"},{"location":"getting-started/installation/#option-b-installation-in-a-dedicated-environment","title":"Option B: Installation in a Dedicated Environment","text":"<p>Creating a separate environment keeps pydvma and its dependencies isolated from other projects:</p> <pre><code># Create a new environment\nconda create --name pydvma-env python=3.13\n\n# Activate the environment\nconda activate pydvma-env\n\n# Install dependencies and pydvma\nconda install numpy scipy jupyter matplotlib pyqtgraph ipympl ipywidgets jupyterlab\npip install sounddevice pydvma\n</code></pre> <p>Activating your environment</p> <p>Each time you open a new Anaconda Prompt, you'll need to activate your environment with <code>conda activate pydvma-env</code> before using pydvma.</p>"},{"location":"getting-started/installation/#step-3-download-the-template-notebook","title":"Step 3: Download the Template Notebook","text":"<p>Download the template notebook to get started quickly:</p> <p>Download pydvma_template.ipynb (right-click and \"Save link as...\")</p> <p>Save it to a folder on your computer where you want to work with your data.</p>"},{"location":"getting-started/installation/#step-4-run-jupyter-notebook","title":"Step 4: Run Jupyter Notebook","text":"<p>Open the Anaconda Prompt and run:</p> <pre><code>jupyter notebook --notebook-dir=\"C:\\path\\to\\your\\folder\"\n</code></pre> <p>Replace <code>C:\\path\\to\\your\\folder</code> with the path to the folder where you saved the template notebook. This will open Jupyter in your browser where you can open and run the template.</p> <p>Quick navigation</p> <p>Alternatively, you can simply run <code>jupyter notebook</code> and navigate to your folder using the Jupyter file browser.</p>"},{"location":"getting-started/installation/#optional-national-instruments-daq-support","title":"Optional: National Instruments DAQ Support","text":"<p>For National Instruments hardware (Windows only):</p> <ol> <li>Download and install NI-DAQmx driver (version 17.6 recommended):</li> </ol> <p>Download NI-DAQmx</p> <ol> <li>Install the Python bindings:</li> </ol> <pre><code>pip install pydaqmx\n</code></pre> <p>Windows Only</p> <p>National Instruments DAQ support is only available on Windows. Soundcard acquisition works on all platforms.</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify your installation, open a Python console or Jupyter notebook and try:</p> <pre><code>import pydvma as dvma\nprint(\"pydvma installed successfully!\")\n</code></pre> <p>If no errors occur, you're ready to go!</p>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<p>Import Error: No module named 'pydvma'</p> <p>Make sure pydvma is installed in the correct Python environment. If using a dedicated environment, ensure you've activated it with <code>conda activate pydvma-env</code>.</p> <p>Qt Platform Plugin Error</p> <p>If you encounter Qt-related errors, try installing PyQt5:</p> <pre><code>pip install pyqt5\n</code></pre> <p>Matplotlib Backend Issues</p> <p>If plots don't display correctly in Jupyter, add this to the first cell of your notebook:</p> <pre><code>%matplotlib qt\n</code></pre> <p>Soundcard Not Detected</p> <p>Ensure sounddevice is installed and your audio device is properly connected:</p> <pre><code>pip install sounddevice\n</code></pre> <p>You can list available audio devices with:</p> <pre><code>import sounddevice as sd\nprint(sd.query_devices())\n</code></pre>"},{"location":"getting-started/installation/#installation-from-source","title":"Installation from Source","text":"<p>For development or to get the latest changes:</p> <pre><code>git clone https://github.com/torebutlin/pydvma.git\ncd pydvma\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installation is complete, proceed to the Quick Start guide to begin using pydvma.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will help you get started with pydvma quickly.</p>"},{"location":"getting-started/quickstart/#opening-the-template","title":"Opening the Template","text":"<p>The easiest way to get started is to use the provided Jupyter notebook template:</p> <ol> <li>Navigate to your pydvma installation directory</li> <li>Open <code>pydvma_template.ipynb</code> in Jupyter</li> </ol> <p>Alternatively, you can start from scratch in any Jupyter notebook or Python script.</p>"},{"location":"getting-started/quickstart/#basic-setup","title":"Basic Setup","text":""},{"location":"getting-started/quickstart/#import-and-configure","title":"Import and Configure","text":"<pre><code>import pydvma as dvma\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# For interactive plots in Jupyter\n%matplotlib qt\n</code></pre>"},{"location":"getting-started/quickstart/#create-settings","title":"Create Settings","text":"<pre><code># Create default settings\nsettings = dvma.MySettings()\n\n# Customize as needed\nsettings.fs = 10000  # Sampling frequency in Hz\nsettings.stored_time = 2.0  # Duration in seconds\nsettings.channels = 2  # Number of channels\n</code></pre>"},{"location":"getting-started/quickstart/#launch-the-logger","title":"Launch the Logger","text":"<pre><code># Create and launch the logger GUI\nlogger = dvma.Logger(settings)\n</code></pre> <p>This opens an interactive GUI where you can:</p> <ul> <li>Configure acquisition parameters</li> <li>Preview signals in real-time</li> <li>Record time-series data</li> <li>Perform FFT analysis</li> <li>Calculate transfer functions</li> <li>View sonograms</li> <li>Export data</li> </ul>"},{"location":"getting-started/quickstart/#your-first-measurement","title":"Your First Measurement","text":""},{"location":"getting-started/quickstart/#using-the-gui","title":"Using the GUI","text":"<ol> <li>Set up your hardware - Connect your sensors/microphones</li> <li>Configure channels - Use the channel settings in the GUI</li> <li>Preview signals - Check signal levels before recording</li> <li>Record data - Click the record button</li> <li>Analyze - Switch between Time, FFT, and TF views</li> </ol>"},{"location":"getting-started/quickstart/#programmatic-recording","title":"Programmatic Recording","text":"<p>You can also record data programmatically:</p> <pre><code># Record data\ndataset = dvma.log_data(settings, test_name=\"test_01\")\n\n# Access the recorded data\ntime_data = dataset.time_data_list[0]\nt = time_data.time_axis\ny = time_data.time_data\n\n# Plot\nplt.plot(t, y)\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.show()\n</code></pre>"},{"location":"getting-started/quickstart/#basic-analysis","title":"Basic Analysis","text":""},{"location":"getting-started/quickstart/#compute-fft","title":"Compute FFT","text":"<pre><code># Calculate FFT\nfreq_data = dvma.calculate_fft(time_data, window='hann')\n\n# Plot\nplt.figure()\nplt.plot(freq_data.freq_axis, np.abs(freq_data.freq_data))\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Magnitude')\nplt.xlim([0, 1000])\nplt.yscale('log')\nplt.show()\n</code></pre>"},{"location":"getting-started/quickstart/#calculate-transfer-function","title":"Calculate Transfer Function","text":"<pre><code># For multi-channel data, calculate transfer function\n# Channel 0 is input, others are outputs\ntf_data = dvma.calculate_tf(time_data, ch_in=0, window='hann')\n\n# Plot magnitude\nplt.figure()\nplt.plot(tf_data.freq_axis, np.abs(tf_data.tf_data[:, 0]))\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('|H(f)|')\nplt.yscale('log')\nplt.show()\n</code></pre>"},{"location":"getting-started/quickstart/#generate-sonogram","title":"Generate Sonogram","text":"<pre><code># Calculate sonogram (spectrogram)\nsono_data = dvma.calculate_sonogram(time_data)\n\n# Plot\nplt.figure()\nplt.pcolormesh(sono_data.time_axis, sono_data.freq_axis,\n               20*np.log10(np.abs(sono_data.sono_data[:, :, 0])))\nplt.ylabel('Frequency (Hz)')\nplt.xlabel('Time (s)')\nplt.colorbar(label='Magnitude (dB)')\nplt.show()\n</code></pre>"},{"location":"getting-started/quickstart/#saving-and-loading-data","title":"Saving and Loading Data","text":""},{"location":"getting-started/quickstart/#export-to-matlab","title":"Export to Matlab","text":"<pre><code># Export dataset to Matlab format\ndvma.export_to_matlab(dataset)\n</code></pre>"},{"location":"getting-started/quickstart/#export-to-csv","title":"Export to CSV","text":"<pre><code># Export time data to CSV\ndvma.export_to_csv(dataset.time_data_list)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the User Guide for more detailed information</li> <li>Check out Examples for common use cases</li> <li>Review the API Reference for function details</li> </ul>"},{"location":"user-guide/acquisition/","title":"Data Acquisition","text":"<p>This guide covers data acquisition using different hardware interfaces.</p>"},{"location":"user-guide/acquisition/#hardware-support","title":"Hardware Support","text":"<p>pydvma supports multiple acquisition hardware:</p> <ul> <li>Soundcards: Using the sounddevice library</li> <li>National Instruments DAQ: Using NI-DAQmx (Windows only)</li> </ul>"},{"location":"user-guide/acquisition/#soundcard-acquisition","title":"Soundcard Acquisition","text":""},{"location":"user-guide/acquisition/#basic-setup","title":"Basic Setup","text":"<pre><code>import pydvma as dvma\n\nsettings = dvma.MySettings()\nsettings.device_driver = 'soundcard'\nsettings.fs = 44100  # Typical soundcard sample rate\nsettings.stored_time = 2.0\nsettings.channels = 2\n</code></pre>"},{"location":"user-guide/acquisition/#listing-available-devices","title":"Listing Available Devices","text":"<pre><code>import sounddevice as sd\n\n# List all available devices\nprint(sd.query_devices())\n\n# Set specific device by index\nsettings.device_index = 1  # Use the index from sd.query_devices()\n</code></pre>"},{"location":"user-guide/acquisition/#recording","title":"Recording","text":"<pre><code># Using the GUI\nlogger = dvma.Logger(settings)\n\n# Programmatically\ndataset = dvma.log_data(settings, test_name=\"recording_01\")\n</code></pre>"},{"location":"user-guide/acquisition/#national-instruments-daq","title":"National Instruments DAQ","text":""},{"location":"user-guide/acquisition/#requirements","title":"Requirements","text":"<ul> <li>NI-DAQmx driver installed</li> <li>pydaqmx Python package</li> <li>Windows operating system</li> </ul>"},{"location":"user-guide/acquisition/#configuration","title":"Configuration","text":"<pre><code>settings = dvma.MySettings()\nsettings.device_driver = 'nidaq'\nsettings.device_index = 0  # Device index (typically 0 for first NI device)\nsettings.fs = 10000\nsettings.stored_time = 2.0\nsettings.channels = 4\n\n# Voltage range (maximum voltage)\nsettings.VmaxNI = 10  # \u00b110V range\n</code></pre>"},{"location":"user-guide/acquisition/#terminal-configuration","title":"Terminal Configuration","text":"<pre><code># Referenced Single-Ended (default)\nsettings.NI_mode = 'DAQmx_Val_RSE'\n\n# Differential\nsettings.NI_mode = 'DAQmx_Val_Diff'\n\n# Non-referenced single-ended\nsettings.NI_mode = 'DAQmx_Val_NRSE'\n</code></pre>"},{"location":"user-guide/acquisition/#triggered-acquisition","title":"Triggered Acquisition","text":""},{"location":"user-guide/acquisition/#pre-trigger-recording","title":"Pre-trigger Recording","text":"<p>Useful for capturing transient events like impacts:</p> <pre><code>settings.pretrig_samples = 2000  # Samples to keep before trigger\n\n# Set trigger parameters\nsettings.pretrig_threshold = 0.5  # Voltage threshold\nsettings.pretrig_channel = 0      # Channel to monitor\nsettings.pretrig_timeout = 20     # Timeout in seconds\n</code></pre> <p>When recording starts, the system continuously buffers data. When the trigger condition is met (signal exceeds threshold), it saves the pre-trigger samples plus the post-trigger duration.</p>"},{"location":"user-guide/acquisition/#output-generation","title":"Output Generation","text":"<p>Generate signals during acquisition (e.g., for transfer function measurements). The built-in generator supports <code>sig='gaussian'</code>, <code>'uniform'</code>, or <code>'sweep'</code> and returns <code>(t, output)</code> where <code>output</code> has shape <code>(samples, settings.output_channels)</code>.</p>"},{"location":"user-guide/acquisition/#gaussian-white-noise-output","title":"Gaussian White Noise Output","text":"<pre><code># Generate white noise signal\nt, output = dvma.signal_generator(\n    settings,\n    sig='gaussian',\n    T=settings.stored_time,\n    amplitude=0.1\n)\n\n# Record with output\ndataset = dvma.log_data(settings, output=output)\n</code></pre>"},{"location":"user-guide/acquisition/#sine-sweep-chirp-output","title":"Sine Sweep (Chirp) Output","text":"<pre><code># Generate sine sweep from f1 to f2\nt, output = dvma.signal_generator(\n    settings,\n    sig='sweep',\n    T=settings.stored_time,\n    amplitude=0.5,\n    f=[10, 1000]  # Start and end frequencies (Hz)\n)\n\n# Record with output\ndataset = dvma.log_data(settings, output=output)\n</code></pre>"},{"location":"user-guide/acquisition/#custom-waveform","title":"Custom Waveform","text":"<pre><code>import numpy as np\n\n# Create custom single-channel waveform (2D array expected)\nt = np.arange(0, settings.stored_time, 1 / settings.output_fs)\ncarrier = 0.5 * np.sin(2 * np.pi * 50 * t)\noutput = carrier[:, None]  # (samples, channels)\n\n# Example: multi-tone signal\ntones = np.array([100, 200, 500])\nmultitone = 0.2 * np.sin(2 * np.pi * tones[:, None] * t).sum(axis=0)\noutput = multitone[:, None]\n\n# Record with custom output\ndataset = dvma.log_data(settings, output=output)\n</code></pre>"},{"location":"user-guide/acquisition/#calibration-and-scaling","title":"Calibration and Scaling","text":""},{"location":"user-guide/acquisition/#sensor-sensitivity","title":"Sensor Sensitivity","text":"<p>Apply sensor sensitivity calibration:</p> <pre><code># Accelerometer sensitivity: 100 mV/g\nsensitivity_accel = 100e-3  # V/g\n\n# After recording\ntime_data.time_data[:, 0] /= sensitivity_accel  # Convert to g\n</code></pre>"},{"location":"user-guide/acquisition/#engineering-units","title":"Engineering Units","text":"<pre><code># Store channel information\ntime_data.channel_names = ['Accel_X', 'Accel_Y', 'Force']\ntime_data.channel_units = ['g', 'g', 'N']\n</code></pre>"},{"location":"user-guide/acquisition/#multiple-measurements","title":"Multiple Measurements","text":""},{"location":"user-guide/acquisition/#recording-multiple-datasets","title":"Recording Multiple Datasets","text":"<pre><code># Create dataset to hold multiple measurements\ndataset = dvma.DataSet()\n\nfor i in range(10):\n    # Record\n    data = dvma.log_data(settings, test_name=f\"test_{i:02d}\")\n\n    # Add to dataset\n    dataset.time_data_list.append(data.time_data_list[0])\n</code></pre>"},{"location":"user-guide/acquisition/#batch-processing","title":"Batch Processing","text":"<pre><code># Process all measurements\nfor i, time_data in enumerate(dataset.time_data_list):\n    # Calculate FFT for each\n    freq_data = dvma.calculate_fft(time_data)\n    dataset.freq_data_list.append(freq_data)\n</code></pre>"},{"location":"user-guide/acquisition/#monitoring-and-visualization","title":"Monitoring and Visualization","text":""},{"location":"user-guide/acquisition/#real-time-preview","title":"Real-time Preview","text":"<p>The Logger GUI provides real-time visualization:</p> <pre><code>logger = dvma.Logger(settings)\n# Use the \"Preview\" button to see signals in real-time\n</code></pre>"},{"location":"user-guide/acquisition/#oscilloscope-view","title":"Oscilloscope View","text":"<p>Monitor input signals before recording:</p> <pre><code># In the GUI, use the \"Oscilloscope\" tab\n# Adjust trigger levels and time scales interactively\n</code></pre>"},{"location":"user-guide/acquisition/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/acquisition/#sample-rate-selection","title":"Sample Rate Selection","text":"<p>Choose appropriate sample rates:</p> <ul> <li>Audio/vibration: 10-50 kHz</li> <li>Ultrasonic: 100+ kHz</li> <li>Slow processes: 1-10 Hz</li> </ul> <p>Remember Nyquist: sample at least 2\u00d7 the highest frequency of interest.</p>"},{"location":"user-guide/acquisition/#duration-selection","title":"Duration Selection","text":"<pre><code># For frequency resolution \u0394f\ndf = 1.0  # Hz resolution desired\nsettings.stored_time = 1.0 / df  # Minimum duration needed\n</code></pre>"},{"location":"user-guide/acquisition/#anti-aliasing","title":"Anti-aliasing","text":"<p>Ensure hardware anti-aliasing filters are enabled or use appropriate sample rates to avoid aliasing.</p>"},{"location":"user-guide/acquisition/#grounding-and-shielding","title":"Grounding and Shielding","text":"<ul> <li>Use proper grounding to reduce noise</li> <li>Shield cables for low-level signals</li> <li>Keep signal cables away from power cables</li> </ul>"},{"location":"user-guide/acquisition/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/acquisition/#no-signal-detected","title":"No Signal Detected","text":"<ol> <li>Check connections</li> <li>Verify device settings</li> <li>Check input range/sensitivity</li> <li>Test with known signal source</li> </ol>"},{"location":"user-guide/acquisition/#clippingsaturation","title":"Clipping/Saturation","text":"<ul> <li>Reduce input signal amplitude</li> <li>Adjust voltage range settings</li> <li>Check sensor sensitivity</li> </ul>"},{"location":"user-guide/acquisition/#high-noise-floor","title":"High Noise Floor","text":"<ul> <li>Improve grounding</li> <li>Use differential inputs</li> <li>Shield cables</li> <li>Reduce gain if possible</li> <li>Check for ground loops</li> </ul>"},{"location":"user-guide/acquisition/#trigger-not-working","title":"Trigger Not Working","text":"<ul> <li>Adjust trigger level</li> <li>Check trigger channel</li> <li>Verify signal amplitude</li> <li>Try different trigger slope</li> </ul>"},{"location":"user-guide/acquisition/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Data Analysis</li> <li>Explore Examples</li> </ul>"},{"location":"user-guide/analysis/","title":"Data Analysis","text":"<p>This guide covers the analysis functions available in pydvma.</p>"},{"location":"user-guide/analysis/#frequency-domain-analysis","title":"Frequency Domain Analysis","text":""},{"location":"user-guide/analysis/#fast-fourier-transform-fft","title":"Fast Fourier Transform (FFT)","text":"<p>Convert time-domain signals to frequency domain:</p> <pre><code>import pydvma as dvma\nimport numpy as np\n\n# Calculate FFT\nfreq_data = dvma.calculate_fft(\n    time_data,\n    time_range=None,  # Use all data, or specify [t_start, t_end]\n    window='hann'     # Window function\n)\n\n# Access results\nf = freq_data.freq_axis\nY = freq_data.freq_data  # Complex spectrum\n\n# Plot magnitude spectrum\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.plot(f, np.abs(Y[:, 0]))\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Magnitude')\nplt.yscale('log')\nplt.xlim([0, 1000])\n</code></pre>"},{"location":"user-guide/analysis/#power-spectral-density","title":"Power Spectral Density","text":"<pre><code># Calculate power spectral density\npsd = np.abs(Y)**2\npsd_db = 10 * np.log10(psd)\n\nplt.plot(f, psd_db[:, 0])\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('PSD (dB)')\n</code></pre>"},{"location":"user-guide/analysis/#window-functions","title":"Window Functions","text":"<p>Different windows for different applications:</p> <pre><code># Rectangular - no windowing, best frequency resolution\nfreq_data = dvma.calculate_fft(time_data, window=None)\n\n# Hann - good general purpose, reduces spectral leakage\nfreq_data = dvma.calculate_fft(time_data, window='hann')\n\n# Hamming - similar to Hann\nfreq_data = dvma.calculate_fft(time_data, window='hamming')\n\n# Blackman - excellent frequency selectivity\nfreq_data = dvma.calculate_fft(time_data, window='blackman')\n</code></pre>"},{"location":"user-guide/analysis/#transfer-function-analysis","title":"Transfer Function Analysis","text":""},{"location":"user-guide/analysis/#single-transfer-function","title":"Single Transfer Function","text":"<p>Calculate frequency response functions:</p> <pre><code># Calculate transfer function (input on channel 0)\ntf_data = dvma.calculate_tf(\n    time_data,\n    ch_in=0,          # Input channel index\n    time_range=None,  # Time range to use\n    window='hann',    # Window function\n    N_frames=1,       # Number of frames to average\n    overlap=0.5       # Overlap fraction (0 to 1)\n)\n\n# Access results\nf = tf_data.freq_axis\nH = tf_data.tf_data           # Complex transfer function\ncoh = tf_data.tf_coherence    # Coherence function\n\n# Plot FRF magnitude\nplt.figure()\nplt.loglog(f, np.abs(H[:, 0]))\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('|H(f)|')\nplt.grid(True)\n</code></pre>"},{"location":"user-guide/analysis/#coherence-function","title":"Coherence Function","text":"<p>Assess measurement quality:</p> <pre><code># Plot coherence\nplt.figure()\nplt.semilogx(f, coh[:, 0])\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Coherence')\nplt.ylim([0, 1])\nplt.grid(True)\n</code></pre> <p>Good coherence (close to 1) indicates: - Low noise - Linear system - Good causality</p> <p>Low coherence can indicate: - High noise levels - Non-linear behavior - Uncorrelated signals - Time delays/wraparound</p>"},{"location":"user-guide/analysis/#averaging-for-better-estimates","title":"Averaging for Better Estimates","text":"<pre><code># Frame averaging - split data into overlapping segments\ntf_data = dvma.calculate_tf(\n    time_data,\n    ch_in=0,\n    N_frames=8,    # 8 segments\n    overlap=0.5    # 50% overlap\n)\n</code></pre>"},{"location":"user-guide/analysis/#ensemble-averaging","title":"Ensemble Averaging","text":"<p>For repeated measurements:</p> <pre><code># Multiple impact tests\ntime_data_list = dvma.TimeDataList()\nfor i in range(10):\n    data = dvma.log_data(settings, test_name=f\"impact_{i}\")\n    time_data_list.append(data.time_data_list[0])\n\n# Averaged transfer function\ntf_data_avg = dvma.calculate_tf_averaged(\n    time_data_list,\n    ch_in=0,\n    window='hann'\n)\n</code></pre>"},{"location":"user-guide/analysis/#cross-spectrum-analysis","title":"Cross-Spectrum Analysis","text":""},{"location":"user-guide/analysis/#cross-spectral-matrix","title":"Cross-Spectral Matrix","text":"<p>For multi-channel analysis:</p> <pre><code># Calculate cross-spectrum matrix\ncross_spec = dvma.calculate_cross_spectrum_matrix(\n    time_data,\n    time_range=None,\n    window='hann',\n    N_frames=1,\n    overlap=0.5\n)\n\n# Access cross-spectral density matrix\nPxy = cross_spec.Pxy  # Complex cross-spectrum [chan x chan x freq]\nCxy = cross_spec.Cxy  # Coherence matrix\n\n# Auto-spectrum for channel 0\nP00 = cross_spec.Pxy[0, 0, :]\n</code></pre>"},{"location":"user-guide/analysis/#cross-spectrum-averaging","title":"Cross-Spectrum Averaging","text":"<pre><code># Averaged cross-spectrum from multiple measurements\ncross_spec_avg = dvma.calculate_cross_spectra_averaged(\n    time_data_list,\n    time_range=None,\n    window='hann'\n)\n</code></pre>"},{"location":"user-guide/analysis/#time-frequency-analysis","title":"Time-Frequency Analysis","text":""},{"location":"user-guide/analysis/#sonogram-spectrogram","title":"Sonogram (Spectrogram)","text":"<p>Analyze how frequency content changes over time:</p> <pre><code># Calculate sonogram\nsono_data = dvma.calculate_sonogram(\n    time_data,\n    nperseg=512,    # FFT segment length\n    noverlap=256    # Overlap samples\n)\n\n# Access results\nt = sono_data.time_axis\nf = sono_data.freq_axis\nS = sono_data.sono_data  # Complex spectrogram [freq x time x chan]\n\n# Plot\nplt.figure(figsize=(10, 6))\nplt.pcolormesh(\n    t, f,\n    20*np.log10(np.abs(S[:, :, 0])),\n    shading='gouraud'\n)\nplt.ylabel('Frequency (Hz)')\nplt.xlabel('Time (s)')\nplt.colorbar(label='Magnitude (dB)')\nplt.ylim([0, 2000])\n</code></pre>"},{"location":"user-guide/analysis/#time-frequency-resolution-trade-off","title":"Time-Frequency Resolution Trade-off","text":"<pre><code># Better frequency resolution (worse time resolution)\nsono_long = dvma.calculate_sonogram(time_data, nperseg=2048)\n\n# Better time resolution (worse frequency resolution)\nsono_short = dvma.calculate_sonogram(time_data, nperseg=256)\n</code></pre>"},{"location":"user-guide/analysis/#integration-and-differentiation","title":"Integration and Differentiation","text":""},{"location":"user-guide/analysis/#frequency-domain-integration","title":"Frequency Domain Integration","text":"<p>Convert between kinematic quantities:</p> <pre><code># Get acceleration FFT\nfreq_data_accel = dvma.calculate_fft(time_data)\n\n# Integrate to velocity: v = \u222ba dt \u2192 V = A/(i\u03c9)\nfreq_data_vel = dvma.multiply_by_power_of_iw(\n    freq_data_accel,\n    power=-1,\n    channel_list=[0]\n)\n\n# Integrate to displacement: x = \u222bv dt \u2192 X = V/(i\u03c9)\nfreq_data_disp = dvma.multiply_by_power_of_iw(\n    freq_data_accel,\n    power=-2,\n    channel_list=[0]\n)\n</code></pre>"},{"location":"user-guide/analysis/#for-transfer-functions","title":"For Transfer Functions","text":"<pre><code># Acceleration/Force FRF\ntf_data = dvma.calculate_tf(time_data, ch_in=0)\n\n# Convert to receptance (displacement/force)\ntf_receptance = dvma.multiply_by_power_of_iw(\n    tf_data,\n    power=-2,\n    channel_list=[0]  # Output channels to convert\n)\n\n# Convert to mobility (velocity/force)\ntf_mobility = dvma.multiply_by_power_of_iw(\n    tf_data,\n    power=-1,\n    channel_list=[0]\n)\n</code></pre>"},{"location":"user-guide/analysis/#impulse-response-cleaning","title":"Impulse Response Cleaning","text":"<p>For impact hammer measurements:</p> <pre><code># Clean impulse data (remove after-ring)\ntime_data_clean = dvma.clean_impulse(\n    time_data,\n    ch_impulse=0  # Channel containing impulse\n)\n\n# Then calculate transfer function\ntf_data = dvma.calculate_tf(time_data_clean, ch_in=0)\n</code></pre> <p>This function: - Identifies the impulse - Estimates pulse width - Windows out noise after the response - Preserves the actual response</p>"},{"location":"user-guide/analysis/#peak-detection","title":"Peak Detection","text":"<p>Find peaks in frequency domain:</p> <pre><code>import peakutils as pu\n\n# Get magnitude spectrum\nfreq_data = dvma.calculate_fft(time_data)\nmagnitude = np.abs(freq_data.freq_data[:, 0])\n\n# Find peaks\nthreshold = 0.3  # Relative threshold (0-1)\nmin_dist = 5     # Minimum samples between peaks\npeak_indices = pu.indexes(magnitude, thres=threshold, min_dist=min_dist)\n\n# Get peak frequencies\nf = freq_data.freq_axis\npeak_frequencies = f[peak_indices]\npeak_magnitudes = magnitude[peak_indices]\n\nprint(\"Peak frequencies:\", peak_frequencies)\n</code></pre>"},{"location":"user-guide/analysis/#data-scaling-and-matching","title":"Data Scaling and Matching","text":""},{"location":"user-guide/analysis/#match-multiple-datasets","title":"Match Multiple Datasets","text":"<pre><code># Create list of transfer functions\ntf_list = dvma.TfDataList()\ntf_list.append(tf_1)\ntf_list.append(tf_2)\ntf_list.append(tf_3)\n\n# Calculate scale factors\nfactors = dvma.best_match(\n    tf_list,\n    freq_range=[100, 500],  # Frequency range for matching\n    set_ref=0,              # Reference dataset index\n    ch_ref=0                # Reference channel\n)\n\n# Apply scaling\nfor i, factor in enumerate(factors):\n    tf_list[i].tf_data *= factor[:, None]\n</code></pre>"},{"location":"user-guide/analysis/#advanced-topics","title":"Advanced Topics","text":""},{"location":"user-guide/analysis/#zero-padding","title":"Zero Padding","text":"<p>Increase frequency resolution through zero padding:</p> <pre><code># Pad time signal with zeros\nn_pad = len(time_data.time_data) * 2\ntime_padded = np.vstack([\n    time_data.time_data,\n    np.zeros((n_pad, time_data.time_data.shape[1]))\n])\n\n# Update time data\nimport copy\ntime_data_padded = copy.copy(time_data)\ntime_data_padded.time_data = time_padded\n\n# Calculate FFT\nfreq_data = dvma.calculate_fft(time_data_padded)\n</code></pre>"},{"location":"user-guide/analysis/#band-pass-filtering","title":"Band-pass Filtering","text":"<pre><code>from scipy import signal\n\n# Design filter\nsos = signal.butter(4, [100, 1000], 'bandpass',\n                    fs=time_data.settings.fs, output='sos')\n\n# Apply filter\nfiltered = signal.sosfiltfilt(sos, time_data.time_data, axis=0)\n\n# Update time data\ntime_data_filtered = copy.copy(time_data)\ntime_data_filtered.time_data = filtered\n</code></pre>"},{"location":"user-guide/analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Modal Analysis</li> <li>See Examples for complete workflows</li> <li>Check API Reference for detailed function documentation</li> </ul>"},{"location":"user-guide/import-export/","title":"Import and Export","text":"<p>Guide for importing and exporting data in various formats.</p>"},{"location":"user-guide/import-export/#export-to-matlab","title":"Export to Matlab","text":"<pre><code># Export entire dataset\ndvma.export_to_matlab(dataset)\n\n# This creates a .mat file with all data structures\n</code></pre> <p>The Matlab file contains: - Time data - Frequency data - Transfer function data - Settings and metadata</p>"},{"location":"user-guide/import-export/#export-to-csv","title":"Export to CSV","text":"<pre><code># Export time data\ndvma.export_to_csv(dataset.time_data_list)\n\n# Export frequency data\ndvma.export_to_csv(dataset.freq_data_list)\n\n# Export transfer function data\ndvma.export_to_csv(dataset.tf_data_list)\n</code></pre>"},{"location":"user-guide/import-export/#import-from-matlab","title":"Import from Matlab","text":"<pre><code># Import data from JW Logger format\ndataset = dvma.import_from_matlab_jwlogger()\n</code></pre>"},{"location":"user-guide/import-export/#save-python-objects","title":"Save Python Objects","text":"<pre><code>import pickle\n\n# Save dataset\nwith open('dataset.pkl', 'wb') as f:\n    pickle.dump(dataset, f)\n\n# Load dataset\nwith open('dataset.pkl', 'rb') as f:\n    dataset = pickle.load(f)\n</code></pre>"},{"location":"user-guide/import-export/#export-plots","title":"Export Plots","text":"<pre><code>import matplotlib.pyplot as plt\n\n# After creating a plot\nplt.savefig('figure.png', dpi=300, bbox_inches='tight')\nplt.savefig('figure.pdf', bbox_inches='tight')\n</code></pre>"},{"location":"user-guide/modal-analysis/","title":"Modal Analysis","text":"<p>This guide covers modal analysis capabilities in pydvma.</p>"},{"location":"user-guide/modal-analysis/#overview","title":"Overview","text":"<p>Modal analysis identifies the natural frequencies, damping ratios, and mode shapes of structures. pydvma provides tools for:</p> <ul> <li>Natural frequency identification</li> <li>Damping estimation from decay measurements</li> <li>Single-degree-of-freedom (SDOF) fitting</li> <li>Mode shape visualization</li> </ul>"},{"location":"user-guide/modal-analysis/#damping-from-free-decay-sonogram-method","title":"Damping from Free Decay (Sonogram Method)","text":""},{"location":"user-guide/modal-analysis/#overview_1","title":"Overview","text":"<p>The sonogram-based damping estimation analyzes free decay responses to extract modal parameters. This is particularly useful for impact tests or other transient responses.</p>"},{"location":"user-guide/modal-analysis/#basic-usage","title":"Basic Usage","text":"<pre><code>import pydvma as dvma\n\n# Load or record time data (e.g., from impact test)\ntime_data = dataset.time_data_list[0]\n\n# Calculate damping from sonogram\nfn, Qn, fit_data = dvma.calculate_damping_from_sono(\n    time_data,\n    n_chan=0,       # Channel to analyze\n    nperseg=512,    # FFT segment length\n    start_time=None # Auto-detect start, or specify time\n)\n\n# Results\nprint(f\"Natural frequencies: {fn} Hz\")\nprint(f\"Q factors: {Qn}\")\nprint(f\"Damping ratios: {1/(2*Qn)}\")\n</code></pre>"},{"location":"user-guide/modal-analysis/#understanding-the-results","title":"Understanding the Results","text":"<p>The function returns three values:</p> <ul> <li>fn: Natural frequencies in Hz</li> <li>Qn: Quality factors (Q = 1/(2\u03b6) where \u03b6 is damping ratio)</li> <li>fit_data: Dictionary containing fit visualization data</li> </ul> <pre><code># Calculate damping ratio from Q factor\nzeta = 1 / (2 * Qn)\n\n# Calculate damped natural frequency\nfn_damped = fn * np.sqrt(1 - zeta**2)\n</code></pre>"},{"location":"user-guide/modal-analysis/#visualization","title":"Visualization","text":"<p>The fit data can be visualized to assess fit quality:</p> <pre><code>import matplotlib.pyplot as plt\n\n# fit_data contains:\n# - 't': time axis\n# - 'fits': list of fit dictionaries\n\nfor fit in fit_data['fits']:\n    plt.figure()\n    plt.plot(fit['t_fit'], fit['real_data'], 'x',\n             label='Data')\n    plt.plot(fit['t_fit'], fit['real_fit'], '-',\n             label=f\"Fit: {fit['f_peak']:.1f} Hz, Q={fit['Qn']:.0f}\")\n    plt.xlabel('Time (s)')\n    plt.ylabel('Log amplitude')\n    plt.legend()\n    plt.title('Damping Fit')\n    plt.show()\n</code></pre>"},{"location":"user-guide/modal-analysis/#method-details","title":"Method Details","text":"<p>The algorithm:</p> <ol> <li>Computes a sonogram (short-time Fourier transform)</li> <li>Identifies frequency peaks in the initial spectrum</li> <li>Tracks the decay of each peak over time</li> <li>Fits an exponential decay model to extract damping</li> <li>Returns natural frequencies and damping ratios</li> </ol>"},{"location":"user-guide/modal-analysis/#tips-for-good-results","title":"Tips for Good Results","text":"<p>Segment Length Selection <pre><code># Longer segments = better frequency resolution\nnperseg = 1024  # Good for closely spaced modes\n\n# Shorter segments = better time resolution\nnperseg = 256   # Good for rapidly decaying signals\n</code></pre></p> <p>Data Quality - Ensure good signal-to-noise ratio - Use appropriate sensor range to avoid clipping - Record sufficient decay duration (several periods) - Minimize background noise</p> <p>Start Time <pre><code># Auto-detect (default)\nfn, Qn, fit_data = dvma.calculate_damping_from_sono(time_data, n_chan=0)\n\n# Specify start time manually\nfn, Qn, fit_data = dvma.calculate_damping_from_sono(\n    time_data,\n    n_chan=0,\n    start_time=0.01  # Start analysis at 0.01 seconds\n)\n</code></pre></p>"},{"location":"user-guide/modal-analysis/#sdof-modal-fitting","title":"SDOF Modal Fitting","text":""},{"location":"user-guide/modal-analysis/#single-channel-modal-fitting","title":"Single Channel Modal Fitting","text":"<p>Fit modal parameters from FRF data for a single channel:</p> <pre><code># Calculate transfer function\ntf_data = dvma.calculate_tf(time_data, ch_in=0)\n\n# Select frequency range around a mode\nfreq_range = [180, 220]  # Hz\n\n# Perform single-channel modal fit (returns scipy.optimize.OptimizeResult)\nresult = dvma.modal_fit_single_channel(\n    tf_data,\n    freq_range=freq_range,\n    channel=0,\n    measurement_type='acc'  # 'acc', 'vel', or 'dsp'\n)\n\n# Access fitted parameters\nfn, zeta, modal_constant = result.x[0], result.x[1], result.x[2]\nprint(f\"Natural frequency: {fn:.2f} Hz\")\nprint(f\"Damping ratio: {zeta:.4f}\")\nprint(f\"Modal constant: {modal_constant}\")\n</code></pre> <p>The optimized parameter vector is ordered as <code>[fn, zeta, an, phase, Rk, Rm]</code>.</p>"},{"location":"user-guide/modal-analysis/#multi-channel-modal-fitting","title":"Multi-Channel Modal Fitting","text":"<p>For fitting a single mode across all channels from a list of transfer functions:</p> <pre><code># Fit a single mode for all channels (returns single ModalData object)\nmodal_data = dvma.modal_fit_all_channels(\n    tf_data_list,\n    freq_range=[180, 220],\n    measurement_type='acc'  # 'acc', 'vel', or 'dsp'\n)\n\n# Review results (fn and zn are arrays, one element per fitted mode)\nprint(f\"Natural frequency: {modal_data.fn[0]:.2f} Hz\")\nprint(f\"Damping ratio: {modal_data.zn[0]:.4f}\")\nprint(f\"Modal constants: {modal_data.an}\")\n</code></pre>"},{"location":"user-guide/modal-analysis/#mode-shape-analysis","title":"Mode Shape Analysis","text":""},{"location":"user-guide/modal-analysis/#extracting-mode-shapes","title":"Extracting Mode Shapes","text":"<p>From multi-point FRF measurements:</p> <pre><code># Measure FRFs at multiple locations\ntf_list = dvma.TfDataList()\n\nfor location in measurement_points:\n    # Record and calculate TF\n    data = dvma.log_data(settings, test_name=f\"point_{location}\")\n    tf = dvma.calculate_tf(data.time_data_list[0], ch_in=0)\n    tf_list.append(tf)\n\n# Extract mode shape at natural frequency\nfn_mode = 150  # Hz\nmode_shape = []\nfor tf_data in tf_list:\n    # Find index closest to fn_mode\n    idx = np.argmin(np.abs(tf_data.freq_axis - fn_mode))\n    # Extract complex amplitude at that frequency\n    mode_shape.append(tf_data.tf_data[idx, 0])\n\nmode_shape = np.array(mode_shape)\n</code></pre>"},{"location":"user-guide/modal-analysis/#plotting-mode-shapes","title":"Plotting Mode Shapes","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Define geometry (example: beam with measurement points)\nx_positions = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5])  # meters\n\n# Plot mode shape\nplt.figure()\nplt.plot(x_positions, np.abs(mode_shape), 'o-')\nplt.xlabel('Position (m)')\nplt.ylabel('Amplitude')\nplt.title(f'Mode Shape at {fn_mode} Hz')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"user-guide/modal-analysis/#2d-mode-shapes","title":"2D Mode Shapes","text":"<p>For plate or surface measurements:</p> <pre><code># Define 2D grid of measurement points\nx_grid = np.array([...])  # X coordinates\ny_grid = np.array([...])  # Y coordinates\nmode_shape_2d = np.array([...])  # Mode shape amplitudes\n\n# Create contour plot\nplt.figure(figsize=(10, 8))\nplt.tricontourf(x_grid, y_grid, np.abs(mode_shape_2d), levels=20)\nplt.colorbar(label='Amplitude')\nplt.xlabel('X position (m)')\nplt.ylabel('Y position (m)')\nplt.title(f'Mode Shape at {fn_mode} Hz')\nplt.axis('equal')\nplt.show()\n</code></pre>"},{"location":"user-guide/modal-analysis/#modal-assurance-criterion-mac","title":"Modal Assurance Criterion (MAC)","text":"<p>Compare mode shapes:</p> <pre><code>def calculate_mac(mode1, mode2):\n    \"\"\"Calculate Modal Assurance Criterion between two mode shapes\"\"\"\n    numerator = np.abs(np.dot(mode1.conj(), mode2))**2\n    denominator = np.dot(mode1.conj(), mode1) * np.dot(mode2.conj(), mode2)\n    return numerator / denominator\n\n# Compare two mode shapes\nmac_value = calculate_mac(mode_shape_1, mode_shape_2)\nprint(f\"MAC value: {mac_value:.4f}\")\n\n# MAC close to 1: modes are similar\n# MAC close to 0: modes are different\n</code></pre>"},{"location":"user-guide/modal-analysis/#operating-deflection-shapes-ods","title":"Operating Deflection Shapes (ODS)","text":"<p>Visualize vibration at a specific frequency:</p> <pre><code># Calculate transfer functions at multiple points\ntf_list = [...]  # List of TF measurements\n\n# Extract ODS at operating frequency\nf_operating = 120  # Hz\nods = []\nfor tf_data in tf_list:\n    idx = np.argmin(np.abs(tf_data.freq_axis - f_operating))\n    ods.append(tf_data.tf_data[idx, 0])\nods = np.array(ods)\n\n# Animate ODS\nplt.figure()\nfor phase in np.linspace(0, 2*np.pi, 50):\n    ods_instant = np.real(ods * np.exp(1j*phase))\n    plt.clf()\n    plt.plot(x_positions, ods_instant, 'o-')\n    plt.ylim([-np.max(np.abs(ods)), np.max(np.abs(ods))])\n    plt.pause(0.05)\n</code></pre>"},{"location":"user-guide/modal-analysis/#experimental-modal-analysis-workflow","title":"Experimental Modal Analysis Workflow","text":""},{"location":"user-guide/modal-analysis/#complete-example","title":"Complete Example","text":"<pre><code>import pydvma as dvma\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 1. Setup\nsettings = dvma.MySettings()\nsettings.fs = 10000\nsettings.stored_time = 1.0\nsettings.pretrig_samples = 1000\nsettings.channels = 2  # Force and response\n\n# 2. Acquire data (multiple impacts)\ntime_data_list = dvma.TimeDataList()\nn_averages = 5\n\nfor i in range(n_averages):\n    input(\"Press Enter for next impact...\")\n    data = dvma.log_data(settings, test_name=f\"impact_{i}\")\n    time_data_list.append(data.time_data_list[0])\n\n# 3. Calculate averaged FRF\ntf_data = dvma.calculate_tf_averaged(time_data_list, ch_in=0)\n\n# 4. Plot FRF and coherence\nf = tf_data.freq_axis\nH = tf_data.tf_data[:, 0]\ncoh = tf_data.tf_coherence[:, 0]\n\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))\n\nax1.semilogy(f, np.abs(H))\nax1.set_ylabel('|H(f)| (m/s\u00b2/N)')\nax1.set_title('Frequency Response Function')\nax1.grid(True)\nax1.set_xlim([0, 500])\n\nax2.plot(f, coh)\nax2.set_xlabel('Frequency (Hz)')\nax2.set_ylabel('Coherence')\nax2.set_ylim([0, 1])\nax2.grid(True)\nax2.set_xlim([0, 500])\n\nplt.tight_layout()\nplt.show()\n\n# 5. Identify modes\nfrom scipy.signal import find_peaks\n\n# Find peaks in FRF\nmagnitude = np.abs(H)\npeaks, properties = find_peaks(magnitude, height=np.max(magnitude)*0.1)\n\nnatural_frequencies = f[peaks]\nprint(\"Identified natural frequencies:\")\nfor fn in natural_frequencies:\n    print(f\"  {fn:.2f} Hz\")\n\n# 6. Extract damping (from time data)\nfn, Qn, fit_data = dvma.calculate_damping_from_sono(\n    time_data_list[0],\n    n_chan=1,\n    nperseg=512\n)\n\nprint(\"\\nDamping analysis:\")\nfor i, (freq, Q) in enumerate(zip(fn, Qn)):\n    zeta = 1/(2*Q)\n    print(f\"  Mode {i+1}: f={freq:.2f} Hz, \u03b6={zeta:.4f}, Q={Q:.1f}\")\n</code></pre>"},{"location":"user-guide/modal-analysis/#references-and-further-reading","title":"References and Further Reading","text":"<ul> <li>Ewins, D.J. (2000). Modal Testing: Theory, Practice and Application</li> <li>Maia, N.M.M. &amp; Silva, J.M.M. (1997). Theoretical and Experimental Modal Analysis</li> <li>Inman, D.J. (2013). Engineering Vibration</li> </ul>"},{"location":"user-guide/modal-analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Plotting and Visualization</li> <li>See complete Examples</li> <li>Check API Reference</li> </ul>"},{"location":"user-guide/plotting/","title":"Plotting and Visualization","text":"<p>Brief guide for plotting with pydvma's built-in tools and matplotlib.</p>"},{"location":"user-guide/plotting/#gui-plotting","title":"GUI Plotting","text":"<p>The Logger GUI provides interactive plotting:</p> <pre><code>logger = dvma.Logger(settings, dataset=dataset)\n</code></pre> <p>Features: - Switch between Time, FFT, TF, and Sonogram views - Interactive zoom and pan - Channel selection - Export plots</p>"},{"location":"user-guide/plotting/#custom-plotting-with-matplotlib","title":"Custom Plotting with Matplotlib","text":""},{"location":"user-guide/plotting/#time-domain-plots","title":"Time Domain Plots","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\ntime_data = dataset.time_data_list[0]\nt = time_data.time_axis\ny = time_data.time_data\n\nplt.figure(figsize=(10, 6))\nplt.plot(t, y[:, 0], label='Channel 0')\nplt.plot(t, y[:, 1], label='Channel 1')\nplt.xlabel('Time (s)')\nplt.ylabel('Amplitude')\nplt.title('Time Domain Signal')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"user-guide/plotting/#frequency-domain-plots","title":"Frequency Domain Plots","text":"<pre><code>freq_data = dvma.calculate_fft(time_data)\nf = freq_data.freq_axis\nY = freq_data.freq_data\n\nplt.figure(figsize=(10, 6))\nplt.semilogy(f, np.abs(Y[:, 0]))\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Magnitude')\nplt.title('FFT Magnitude')\nplt.grid(True)\nplt.xlim([0, 1000])\nplt.show()\n</code></pre>"},{"location":"user-guide/plotting/#frf-plots","title":"FRF Plots","text":"<pre><code>tf_data = dvma.calculate_tf(time_data, ch_in=0)\nf = tf_data.freq_axis\nH = tf_data.tf_data\ncoh = tf_data.tf_coherence\n\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))\n\n# Magnitude\nax1.loglog(f, np.abs(H[:, 0]))\nax1.set_ylabel('|H(f)|')\nax1.set_title('FRF Magnitude')\nax1.grid(True, which='both')\n\n# Coherence\nax2.semilogx(f, coh[:, 0])\nax2.set_xlabel('Frequency (Hz)')\nax2.set_ylabel('Coherence')\nax2.set_ylim([0, 1])\nax2.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/plotting/#sonogram-plots","title":"Sonogram Plots","text":"<pre><code>sono_data = dvma.calculate_sonogram(time_data)\nt = sono_data.time_axis\nf = sono_data.freq_axis\nS = sono_data.sono_data\n\nplt.figure(figsize=(12, 6))\nplt.pcolormesh(t, f, 20*np.log10(np.abs(S[:, :, 0])),\n               shading='gouraud', cmap='viridis')\nplt.ylabel('Frequency (Hz)')\nplt.xlabel('Time (s)')\nplt.colorbar(label='Magnitude (dB)')\nplt.ylim([0, 2000])\nplt.title('Sonogram')\nplt.show()\n</code></pre>"},{"location":"user-guide/plotting/#export-plots","title":"Export Plots","text":"<pre><code># Save figure\nplt.savefig('plot.png', dpi=300, bbox_inches='tight')\nplt.savefig('plot.pdf', bbox_inches='tight')  # Vector format\n</code></pre>"}]}